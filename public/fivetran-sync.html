<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>SPHERE - Fivetran Sync</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Helvetica Neue', Arial, sans-serif;
      display: flex; min-height: 100vh; background: #f8f9fa;
    }

    .sidebar {
      width: 195px; background: #fff; border-right: 1px solid #dfe3e8;
      display: flex; flex-direction: column; box-shadow: 1px 0 0 rgba(0,0,0,0.02);
      position: fixed; top: 0; left: 0; height: 100vh; overflow-y: auto; z-index: 100;
    }
    .logo {
      padding: 18px 20px; border-bottom: 1px solid #dfe3e8;
      display: flex; align-items: center; gap: 10px;
      font-size: 19px; font-weight: 600; color: #1a202c; letter-spacing: -0.3px;
    }
    .logo-icon {
      width: 28px; height: 28px;
      background: linear-gradient(135deg, #3b5998 0%, #2d4373 100%);
      border-radius: 6px; display: flex; align-items: center; justify-content: center;
      color: white; font-size: 14px; font-weight: bold;
    }
    .nav-menu { flex: 1; padding: 8px 0; }
    .nav-item {
      padding: 11px 20px; cursor: pointer; transition: all 0.15s ease;
      color: #4a5568; font-size: 13.5px; font-weight: 400;
      border-left: 3px solid transparent; text-decoration: none; display: block;
    }
    .nav-item:hover:not(.disabled) { background: #f7fafc; color: #2d3748; }
    .nav-item.active { background: #e6f0f8; color: #2d4a68; font-weight: 500; border-left-color: #4a7c9e; }

    .main-content { flex: 1; display: flex; flex-direction: column; overflow: hidden; background: #f8f9fa; margin-left: 195px; }

    .header {
      background: white; padding: 20px 35px; border-bottom: 1px solid #e2e8f0;
      display: flex; justify-content: space-between; align-items: center;
    }
    .header-left h1 { font-size: 24px; color: #1a202c; font-weight: 600; margin-bottom: 4px; }
    .header-left p { color: #718096; font-size: 14px; }
    .header-actions { display: flex; gap: 12px; }

    .content { flex: 1; overflow-y: auto; padding: 25px 35px; }

    .section-card {
      background: white; border-radius: 8px; padding: 24px; margin-bottom: 24px;
      box-shadow: 0 1px 3px rgba(0,0,0,0.06); border: 1px solid #e2e8f0;
    }
    .section-header {
      display: flex; justify-content: space-between; align-items: center;
      margin-bottom: 20px; padding-bottom: 12px; border-bottom: 1px solid #e2e8f0;
    }
    .section-header h2 { font-size: 18px; color: #1a202c; font-weight: 600; }

    /* Pipeline */
    .pipeline { display: flex; align-items: stretch; gap: 0; margin-top: 8px; }
    .pipeline-step {
      flex: 1; padding: 20px; border: 2px solid #e2e8f0; background: #f8f9fa; position: relative;
      transition: border-color 0.3s, background 0.3s;
    }
    .pipeline-step:first-child { border-radius: 8px 0 0 8px; }
    .pipeline-step:last-child { border-radius: 0 8px 8px 0; }
    .pipeline-step.active { border-color: #3182ce; background: #ebf8ff; }
    .pipeline-step.done { border-color: #38a169; background: #f0fff4; }
    .pipeline-step.failed { border-color: #e53e3e; background: #fff5f5; }
    .pipeline-step.waiting { border-color: #e2e8f0; background: #f8f9fa; opacity: 0.6; }

    .pipeline-arrow {
      display: flex; align-items: center; justify-content: center;
      font-size: 20px; color: #a0aec0; padding: 0 4px; flex-shrink: 0;
    }

    .step-label {
      font-size: 11px; text-transform: uppercase; letter-spacing: 0.05em;
      color: #718096; margin-bottom: 4px; font-weight: 600;
    }
    .step-number {
      display: inline-block; width: 20px; height: 20px; border-radius: 50%;
      background: #e2e8f0; color: #4a5568; font-size: 11px; font-weight: 700;
      text-align: center; line-height: 20px; margin-right: 6px;
    }
    .pipeline-step.active .step-number { background: #3182ce; color: white; }
    .pipeline-step.done .step-number { background: #38a169; color: white; }
    .pipeline-step.failed .step-number { background: #e53e3e; color: white; }

    .step-name { font-size: 15px; font-weight: 600; color: #1a202c; margin-bottom: 12px; }
    .step-detail { display: flex; justify-content: space-between; padding: 6px 0; font-size: 13px; border-bottom: 1px solid #edf2f7; }
    .step-detail:last-child { border-bottom: none; }
    .step-detail-label { color: #718096; }
    .step-detail-value { color: #2d3748; font-weight: 500; }

    .status-badge {
      display: inline-block; padding: 4px 12px; border-radius: 12px;
      font-size: 12px; font-weight: 600; text-transform: capitalize;
    }
    .status-badge.connected, .status-badge.scheduled, .status-badge.succeeded { background: #c6f6d5; color: #22543d; }
    .status-badge.syncing, .status-badge.running { background: #bee3f8; color: #2a4365; }
    .status-badge.paused { background: #fefcbf; color: #744210; }
    .status-badge.broken, .status-badge.error, .status-badge.failed { background: #fed7d7; color: #822727; }
    .status-badge.rescheduled { background: #c6f6d5; color: #22543d; }
    .status-badge.unknown, .status-badge.waiting { background: #e2e8f0; color: #4a5568; }

    .btn {
      padding: 10px 20px; border: none; border-radius: 6px;
      font-size: 14px; font-weight: 500; cursor: pointer;
      transition: all 0.15s ease; display: inline-flex; align-items: center; gap: 8px;
    }
    .btn-secondary { background: #e2e8f0; color: #4a5568; }
    .btn-secondary:hover { background: #cbd5e0; }
    .btn-sync { background: #38a169; color: white; padding: 12px 28px; font-size: 15px; }
    .btn-sync:hover:not(:disabled) { background: #2f855a; box-shadow: 0 2px 8px rgba(56,161,105,0.3); }
    .btn-sync:disabled { background: #9ae6b4; cursor: not-allowed; }

    .sync-section { text-align: center; margin: 24px 0 8px; }
    .sync-section p { color: #718096; font-size: 13px; margin-top: 10px; }

    .pipeline-log {
      margin-top: 16px; padding: 12px 16px; background: #1a202c; border-radius: 6px;
      font-family: 'SF Mono', 'Consolas', monospace; font-size: 12px; color: #a0aec0;
      max-height: 180px; overflow-y: auto; display: none;
    }
    .pipeline-log.visible { display: block; }
    .pipeline-log .log-entry { padding: 2px 0; }
    .pipeline-log .log-entry.info { color: #63b3ed; }
    .pipeline-log .log-entry.success { color: #68d391; }
    .pipeline-log .log-entry.error { color: #fc8181; }
    .pipeline-log .log-entry .timestamp { color: #4a5568; margin-right: 8px; }

    .btn-spinner {
      display: inline-block; width: 16px; height: 16px;
      border: 2px solid rgba(255,255,255,0.3); border-top-color: white;
      border-radius: 50%; animation: spin 1s linear infinite;
    }
    .loading { text-align: center; padding: 40px; color: #718096; }
    .loading-spinner {
      display: inline-block; width: 24px; height: 24px;
      border: 3px solid #e2e8f0; border-top-color: #5a6fd8;
      border-radius: 50%; animation: spin 1s linear infinite; margin-bottom: 12px;
    }
    @keyframes spin { to { transform: rotate(360deg); } }

    .toast-container { position: fixed; top: 20px; right: 20px; z-index: 1000; display: flex; flex-direction: column; gap: 10px; }
    .toast {
      padding: 12px 20px; border-radius: 8px; font-size: 14px; font-weight: 500;
      box-shadow: 0 4px 12px rgba(0,0,0,0.15); animation: slideIn 0.3s ease;
    }
    .toast.success { background: #38a169; color: white; }
    .toast.error { background: #e53e3e; color: white; }
    .toast.info { background: #3182ce; color: white; }
    @keyframes slideIn { from { transform: translateX(100%); opacity: 0; } to { transform: translateX(0); opacity: 1; } }

    .empty-state { text-align: center; padding: 48px 24px; color: #718096; }
    .empty-state h3 { font-size: 16px; margin-bottom: 8px; color: #4a5568; }
  </style>
</head>
<body>
  <div class="sidebar">
    <div class="logo"><div class="logo-icon">S</div> SPHERE</div>
    <nav class="nav-menu">
      <a href="/" class="nav-item">P&L View</a>
      <a href="/dimension-config" class="nav-item">Dimension Config</a>
      <a href="/email-config" class="nav-item">Email Config</a>
      <a href="/run-log" class="nav-item">Run Log</a>
      <a href="/fivetran-sync" class="nav-item active">Fivetran Sync</a>
    </nav>
  </div>

  <div class="main-content">
    <div class="header">
      <div class="header-left">
        <h1>Fivetran Sync</h1>
        <p>Sync NetSuite data connectors and monitor transformation pipeline</p>
      </div>
      <div class="header-actions">
        <button class="btn btn-secondary" onclick="loadStatus()">Refresh</button>
      </div>
    </div>

    <div class="content">
      <div class="section-card">
        <div class="sync-section">
          <button class="btn btn-sync" id="sync-btn" onclick="runPipeline()">
            Run Full Pipeline
          </button>
          <p>Syncs netsuite_accounts first, then netsuite_connector_main (which triggers the dbt transformation via integrated schedule).</p>
        </div>
        <div class="pipeline-log" id="pipeline-log"></div>
      </div>

      <div class="section-card">
        <div class="section-header"><h2>Pipeline Status</h2></div>
        <div id="pipeline-container">
          <div class="loading"><div class="loading-spinner"></div><div>Loading pipeline status...</div></div>
        </div>
      </div>
    </div>
  </div>

  <div class="toast-container" id="toast-container"></div>

  <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-auth-compat.js"></script>
  <script src="/auth.js"></script>

  <script>
    // Pipeline config â€” order matters
    const CONNECTORS = [
      { id: 'plaster_bang', schema: 'netsuite_accounts' },
      { id: 'conventional_industrious', schema: 'netsuite_connector_main' }
    ];
    const TRANSFORMATION_ID = 'justness_luminous';

    let pipelineRunning = false;
    // Track which step is active/done during a run:
    // 'idle' | 'connector-0' | 'connector-1' | 'transformation' | 'done' | 'failed'
    let pipelinePhase = 'idle';

    document.addEventListener('DOMContentLoaded', () => { loadStatus(); });

    function showToast(msg, type = 'info') {
      const c = document.getElementById('toast-container');
      const t = document.createElement('div');
      t.className = `toast ${type}`;
      t.textContent = msg;
      c.appendChild(t);
      setTimeout(() => t.remove(), 5000);
    }

    function formatDT(d) {
      if (!d) return 'Never';
      return new Date(d).toLocaleString('en-US', { month: 'short', day: 'numeric', year: 'numeric', hour: 'numeric', minute: '2-digit', hour12: true });
    }

    function timeAgo(d) {
      if (!d) return '';
      const m = Math.floor((Date.now() - new Date(d).getTime()) / 60000);
      if (m < 1) return '(just now)';
      if (m < 60) return `(${m}m ago)`;
      const h = Math.floor(m / 60);
      if (h < 24) return `(${h}h ago)`;
      return `(${Math.floor(h / 24)}d ago)`;
    }

    function connSyncState(c) {
      if (c.error) return 'error';
      if (c.paused) return 'paused';
      return c.status?.sync_state || 'unknown';
    }

    function transState(t) {
      if (t.error) return 'error';
      if (t.paused) return 'paused';
      return (t.status || '').toLowerCase() || 'unknown';
    }

    // Logging
    function log(msg, type = 'info') {
      const el = document.getElementById('pipeline-log');
      el.classList.add('visible');
      const ts = new Date().toLocaleTimeString();
      el.innerHTML += `<div class="log-entry ${type}"><span class="timestamp">[${ts}]</span>${escapeHtml(msg)}</div>`;
      el.scrollTop = el.scrollHeight;
    }

    function clearLog() {
      const el = document.getElementById('pipeline-log');
      el.innerHTML = '';
      el.classList.remove('visible');
    }

    // Status loading
    async function loadStatus() {
      const container = document.getElementById('pipeline-container');
      try {
        const res = await authFetch('/api/fivetran/status');
        if (!res.ok) throw new Error((await res.json()).message || 'Failed');
        const data = await res.json();
        renderPipeline(data.connectors, data.transformation);
      } catch (e) {
        container.innerHTML = `<div class="empty-state"><h3>Failed to load status</h3><p>${escapeHtml(e.message)}</p></div>`;
      }
    }

    function stepClass(stepIndex) {
      if (pipelinePhase === 'idle') return '';
      if (pipelinePhase === 'failed') return '';
      if (pipelinePhase === 'done') return 'done';

      // During a run
      if (pipelinePhase === 'connector-0') {
        if (stepIndex === 0) return 'active';
        return 'waiting';
      }
      if (pipelinePhase === 'connector-1') {
        if (stepIndex === 0) return 'done';
        if (stepIndex === 1) return 'active';
        return 'waiting';
      }
      if (pipelinePhase === 'transformation') {
        if (stepIndex <= 1) return 'done';
        if (stepIndex === 2) return 'active';
      }
      return '';
    }

    function renderPipeline(connectors, transformation) {
      const container = document.getElementById('pipeline-container');

      const stepsHtml = connectors.map((c, i) => {
        const state = connSyncState(c);
        const cls = stepClass(i);
        if (c.error) {
          return `<div class="pipeline-step ${cls}">
            <div class="step-label"><span class="step-number">${i + 1}</span>Connector</div>
            <div class="step-name">${escapeHtml(c.id)}</div>
            <div class="step-detail"><span class="step-detail-label">Status</span><span class="status-badge error">Error</span></div>
            <div class="step-detail"><span class="step-detail-label">Error</span><span class="step-detail-value" style="color:#e53e3e">${escapeHtml(c.error)}</span></div>
          </div>`;
        }
        return `<div class="pipeline-step ${cls}">
          <div class="step-label"><span class="step-number">${i + 1}</span>Connector</div>
          <div class="step-name">${escapeHtml(c.name)}</div>
          <div class="step-detail"><span class="step-detail-label">Status</span><span class="status-badge ${state}">${state}</span></div>
          <div class="step-detail"><span class="step-detail-label">Last Sync</span><span class="step-detail-value">${formatDT(c.succeeded_at)} ${timeAgo(c.succeeded_at)}</span></div>
          ${c.failed_at ? `<div class="step-detail"><span class="step-detail-label">Last Failure</span><span class="step-detail-value" style="color:#e53e3e">${formatDT(c.failed_at)}</span></div>` : ''}
        </div>`;
      });

      const tState = transState(transformation);
      const tCls = stepClass(2);
      const tHtml = transformation.error
        ? `<div class="pipeline-step ${tCls}">
            <div class="step-label"><span class="step-number">3</span>Transformation</div>
            <div class="step-name">dbt Core</div>
            <div class="step-detail"><span class="step-detail-label">Status</span><span class="status-badge error">Error</span></div>
            <div class="step-detail"><span class="step-detail-label">Error</span><span class="step-detail-value" style="color:#e53e3e">${escapeHtml(transformation.error)}</span></div>
          </div>`
        : `<div class="pipeline-step ${tCls}">
            <div class="step-label"><span class="step-number">3</span>Transformation</div>
            <div class="step-name">dbt Core</div>
            <div class="step-detail"><span class="step-detail-label">Status</span><span class="status-badge ${tState}">${tState}</span></div>
            <div class="step-detail"><span class="step-detail-label">Last Started</span><span class="step-detail-value">${formatDT(transformation.last_started_at)} ${timeAgo(transformation.last_started_at)}</span></div>
            <div class="step-detail"><span class="step-detail-label">Last Completed</span><span class="step-detail-value">${formatDT(transformation.last_ended_at)} ${timeAgo(transformation.last_ended_at)}</span></div>
          </div>`;

      const arrow = '<div class="pipeline-arrow">&#8594;</div>';
      container.innerHTML = `<div class="pipeline">${stepsHtml.join(arrow)}${arrow}${tHtml}</div>`;
    }

    // ========== Sequential Pipeline ==========
    function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }

    async function fetchStatus() {
      const res = await authFetch('/api/fivetran/status');
      if (!res.ok) throw new Error('Failed to fetch status');
      return await res.json();
    }

    async function triggerConnector(connectorId) {
      const res = await authFetch(`/api/fivetran/connectors/${connectorId}/sync`, { method: 'POST' });
      if (!res.ok) {
        const data = await res.json();
        throw new Error(data.message || 'Failed to trigger sync');
      }
      return await res.json();
    }

    async function waitForConnector(connectorId, stepIndex) {
      const POLL_INTERVAL = 15000;
      const MAX_POLLS = 80; // ~20 minutes

      for (let i = 0; i < MAX_POLLS; i++) {
        await sleep(POLL_INTERVAL);
        const data = await fetchStatus();
        renderPipeline(data.connectors, data.transformation);

        const connector = data.connectors.find(c => c.id === connectorId);
        if (!connector) throw new Error(`Connector ${connectorId} not found in status`);

        const state = connector.status?.sync_state;
        log(`  ${connector.name}: sync_state = ${state}`);

        if (state === 'scheduled' || state === 'rescheduled') {
          return connector;
        }
        if (connector.error) {
          throw new Error(`Connector ${connector.name} error: ${connector.error}`);
        }
      }
      throw new Error('Timed out waiting for connector sync');
    }

    async function waitForTransformation() {
      const POLL_INTERVAL = 15000;
      const MAX_POLLS = 40; // ~10 minutes

      for (let i = 0; i < MAX_POLLS; i++) {
        await sleep(POLL_INTERVAL);
        const data = await fetchStatus();
        renderPipeline(data.connectors, data.transformation);

        const t = data.transformation;
        const status = (t.status || '').toUpperCase();
        log(`  Transformation: status = ${status}`);

        if (status === 'SUCCEEDED') return t;
        if (status === 'FAILED') throw new Error('dbt transformation failed');
        if (t.error) throw new Error(`Transformation error: ${t.error}`);
      }
      throw new Error('Timed out waiting for transformation');
    }

    async function runPipeline() {
      if (pipelineRunning) return;
      pipelineRunning = true;

      const btn = document.getElementById('sync-btn');
      btn.disabled = true;
      btn.innerHTML = '<span class="btn-spinner"></span> Running Pipeline...';
      clearLog();

      try {
        // Step 1: Sync first connector
        pipelinePhase = 'connector-0';
        const c1 = CONNECTORS[0];
        log(`Step 1: Triggering sync for ${c1.schema}...`);
        await triggerConnector(c1.id);
        log(`  Sync triggered. Waiting for completion...`);
        await loadStatus();
        const done1 = await waitForConnector(c1.id, 0);
        log(`Step 1 complete: ${c1.schema} synced at ${done1.succeeded_at}`, 'success');

        // Step 2: Sync second connector
        pipelinePhase = 'connector-1';
        await loadStatus();
        const c2 = CONNECTORS[1];
        log(`Step 2: Triggering sync for ${c2.schema}...`);
        await triggerConnector(c2.id);
        log(`  Sync triggered. Waiting for completion...`);
        await loadStatus();
        const done2 = await waitForConnector(c2.id, 1);
        log(`Step 2 complete: ${c2.schema} synced at ${done2.succeeded_at}`, 'success');

        // Step 3: Wait for transformation (auto-triggered by integrated schedule after connector 2)
        pipelinePhase = 'transformation';
        await loadStatus();
        log(`Step 3: Waiting for dbt transformation to complete...`);
        const tResult = await waitForTransformation();
        log(`Step 3 complete: Transformation succeeded at ${tResult.last_ended_at}`, 'success');

        pipelinePhase = 'done';
        await loadStatus();
        log('Pipeline complete!', 'success');
        showToast('Full pipeline complete: connectors synced and transformation succeeded', 'success');

      } catch (error) {
        pipelinePhase = 'failed';
        log(`Pipeline failed: ${error.message}`, 'error');
        showToast(`Pipeline failed: ${error.message}`, 'error');
        await loadStatus();
      } finally {
        pipelineRunning = false;
        btn.disabled = false;
        btn.innerHTML = 'Run Full Pipeline';
        // Reset phase after a moment so the visual state clears on next refresh
        setTimeout(() => { pipelinePhase = 'idle'; }, 10000);
      }
    }

    function escapeHtml(str) {
      if (str == null) return '';
      const d = document.createElement('div');
      d.textContent = str;
      return d.innerHTML;
    }
  </script>
</body>
</html>
