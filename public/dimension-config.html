<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>SPHERE - Dimension Configuration</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Helvetica Neue', Arial, sans-serif;
      display: flex;
      height: 100vh;
      background: #f8f9fa;
      overflow: hidden;
    }

    /* Sidebar */
    .sidebar {
      width: 195px;
      background: #ffffff;
      border-right: 1px solid #dfe3e8;
      display: flex;
      flex-direction: column;
      box-shadow: 1px 0 0 rgba(0,0,0,0.02);
    }

    .logo {
      padding: 18px 20px;
      border-bottom: 1px solid #dfe3e8;
      display: flex;
      align-items: center;
      gap: 10px;
      font-size: 19px;
      font-weight: 600;
      color: #1a202c;
      letter-spacing: -0.3px;
    }

    .logo-icon {
      width: 28px;
      height: 28px;
      background: linear-gradient(135deg, #3b5998 0%, #2d4373 100%);
      border-radius: 6px;
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      font-size: 14px;
      font-weight: bold;
    }

    .nav-menu {
      flex: 1;
      padding: 8px 0;
    }

    .nav-item {
      padding: 11px 20px;
      cursor: pointer;
      transition: all 0.15s ease;
      color: #4a5568;
      font-size: 13.5px;
      font-weight: 400;
      border-left: 3px solid transparent;
    }

    .nav-item:hover:not(.disabled) {
      background: #f7fafc;
      color: #2d3748;
    }

    .nav-item.active {
      background: #e6f0f8;
      color: #2d4a68;
      font-weight: 500;
      border-left-color: #4a7c9e;
    }

    .nav-item.disabled {
      color: #cbd5e0;
      cursor: not-allowed;
    }

    /* Main Content */
    .main-content {
      flex: 1;
      display: flex;
      flex-direction: column;
      overflow: hidden;
      background: #ffffff;
    }

    /* Header Tabs */
    .header-tabs {
      background: #f8f9fa;
      padding: 12px 20px;
      display: flex;
      gap: 8px;
      border-bottom: 1px solid #e0e0e0;
    }

    .tab {
      padding: 8px 20px;
      background: #e8ecef;
      border: none;
      cursor: pointer;
      font-size: 12px;
      font-weight: 500;
      color: #555;
      transition: all 0.2s;
      border-radius: 4px 4px 0 0;
    }

    .tab:hover:not(.active) {
      background: #dce1e5;
    }

    .tab.active {
      background: #ffffff;
      color: #2d3748;
      font-weight: 600;
    }

    /* Controls */
    .controls {
      background: white;
      padding: 12px 20px;
      border-bottom: 1px solid #e0e0e0;
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .search-box {
      flex: 1;
      max-width: 300px;
    }

    .search-box input {
      width: 100%;
      padding: 6px 10px;
      border: 1px solid #ccc;
      border-radius: 3px;
      font-size: 12px;
    }

    .search-box input:focus {
      outline: none;
      border-color: #2196F3;
    }

    .btn {
      padding: 6px 14px;
      border: 1px solid #ccc;
      border-radius: 3px;
      background: #f5f5f5;
      cursor: pointer;
      font-size: 11px;
      font-weight: 500;
      transition: all 0.15s;
    }

    .btn:hover {
      background: #e0e0e0;
    }

    .stats {
      margin-left: auto;
      font-size: 11px;
      color: #666;
      display: flex;
      gap: 12px;
    }

    /* Tree Content */
    .tree-content {
      flex: 1;
      overflow-y: auto;
      background: #ffffff;
    }

    .loading-state, .error-state {
      text-align: center;
      padding: 40px 20px;
      color: #666;
      font-size: 13px;
    }

    .error-state {
      color: #d32f2f;
    }

    /* Tree Node - Compact Retool Styling */
    .tree-node {
      list-style: none;
      margin: 0;
      padding: 0;
    }

    .node-item {
      display: flex;
      align-items: center;
      padding: 4px 6px;
      border-bottom: 1px solid #f0f0f0;
      background-color: white;
      transition: background-color 0.1s ease;
      min-height: 30px;
      position: relative;
    }

    .node-item:hover {
      background-color: #f9f9f9;
    }

    .node-actions {
      display: none;
      position: absolute;
      right: 8px;
      top: 50%;
      transform: translateY(-50%);
      gap: 4px;
    }

    .node-item:hover .node-actions {
      display: flex;
    }

    .btn-drag-handle {
      width: 20px;
      height: 20px;
      border-radius: 3px;
      border: none;
      background: #9e9e9e;
      color: white;
      cursor: grab;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 10px;
      font-weight: bold;
      letter-spacing: -2px;
      transition: background 0.15s;
      margin-right: 4px;
    }

    .btn-drag-handle:hover {
      background: #757575;
    }

    .btn-drag-handle:active {
      cursor: grabbing;
    }

    .btn-edit {
      width: 20px;
      height: 20px;
      border-radius: 3px;
      border: none;
      background: #2196F3;
      color: white;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 11px;
      transition: background 0.15s;
    }

    .btn-edit:hover {
      background: #1976D2;
    }

    .btn-add-child {
      width: 20px;
      height: 20px;
      border-radius: 3px;
      border: none;
      background: #4CAF50;
      color: white;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 14px;
      font-weight: bold;
      padding: 0;
      margin-right: 4px;
      transition: background 0.15s;
    }

    .btn-add-child:hover {
      background: #45a049;
    }

    .btn-delete {
      width: 20px;
      height: 20px;
      border-radius: 3px;
      border: none;
      background: #f44336;
      color: white;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 14px;
      font-weight: bold;
      padding: 0;
      margin-left: 4px;
      transition: background 0.15s;
    }

    .btn-delete:hover {
      background: #d32f2f;
    }

    li.dragging {
      opacity: 0.5;
    }

    li.drag-over {
      border-top: 2px solid #2196F3;
    }

    .node-icon-container {
      width: 16px;
      display: flex;
      justify-content: center;
      margin-right: 4px;
      color: #333;
    }

    .node-chevron {
      width: 8px;
      height: 8px;
      display: block;
    }

    .node-label {
      font-size: 12px;
      color: #333;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
      flex: 1;
      display: flex;
      align-items: center;
      gap: 6px;
    }

    /* Inline icons and tags */
    .inline-icon {
      width: 14px;
      height: 14px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      flex-shrink: 0;
      vertical-align: middle;
      margin-left: 2px;
      cursor: help;
      position: relative;
    }

    /* Custom instant tooltip */
    .inline-icon[data-tooltip]::after {
      content: attr(data-tooltip);
      position: absolute;
      bottom: 100%;
      left: 50%;
      transform: translateX(-50%) translateY(-4px);
      background: rgba(0, 0, 0, 0.9);
      color: white;
      padding: 6px 10px;
      border-radius: 4px;
      font-size: 12px;
      white-space: nowrap;
      max-width: 300px;
      white-space: normal;
      width: max-content;
      max-width: 300px;
      z-index: 10000;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.1s ease-in-out;
      font-weight: normal;
      line-height: 1.4;
      text-align: left;
    }

    .inline-icon[data-tooltip]:hover::after {
      opacity: 1;
      transition-delay: 0s;
    }

    /* Tooltip arrow */
    .inline-icon[data-tooltip]::before {
      content: '';
      position: absolute;
      bottom: 100%;
      left: 50%;
      transform: translateX(-50%) translateY(4px);
      border: 4px solid transparent;
      border-top-color: rgba(0, 0, 0, 0.9);
      z-index: 10001;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.1s ease-in-out;
    }

    .inline-icon[data-tooltip]:hover::before {
      opacity: 1;
      transition-delay: 0s;
    }

    .tag {
      font-size: 10px;
      padding: 1px 5px;
      border-radius: 8px;
      white-space: nowrap;
    }

    .tag-district {
      background-color: #ede7f6;
      color: #4527a0;
    }

    .tag-customer {
      background-color: #e8f5e9;
      color: #1b5e20;
    }

    .tag-subsidiary {
      background-color: #fff3e0;
      color: #e65100;
    }

    .tag-generic {
      background-color: #e0e0e0;
      color: #555;
    }

    .node-children {
      list-style: none;
      display: none;
    }

    .node-children.expanded {
      display: block;
    }

    /* Empty state */
    .empty-state {
      text-align: center;
      padding: 60px 20px;
      color: #999;
    }

    /* Edit Sidebar */
    .edit-sidebar {
      position: fixed;
      top: 0;
      right: 0;
      bottom: 0;
      width: 340px;
      background: linear-gradient(to bottom, #f8f9fa 0%, #ffffff 120px);
      border-left: 1px solid #cbd5e0;
      box-shadow: -4px 0 16px rgba(0,0,0,0.12);
      padding: 0;
      overflow-y: auto;
      z-index: 100;
      display: none;
    }

    .edit-sidebar.open {
      display: flex;
      flex-direction: column;
    }

    .edit-sidebar-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 20px;
      background: linear-gradient(135deg, #4a7c9e 0%, #3d6a8a 100%);
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      margin-bottom: 0;
      position: sticky;
      top: 0;
      z-index: 10;
    }

    .edit-sidebar-header h3 {
      margin: 0;
      font-size: 16px;
      font-weight: 600;
      color: white;
    }

    .edit-sidebar-content {
      padding: 20px;
    }

    .field-group {
      margin-bottom: 20px;
      padding: 16px;
      background: white;
      border-radius: 6px;
      border: 1px solid #e2e8f0;
    }

    .field-label {
      display: block;
      font-size: 11px;
      font-weight: 600;
      margin-bottom: 8px;
      color: #4a7c9e;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .field-input {
      width: 100%;
      padding: 10px 12px;
      border: 1px solid #cbd5e0;
      border-radius: 4px;
      font-size: 13px;
      background: #f8f9fa;
      transition: all 0.15s;
    }

    .field-input:focus {
      outline: none;
      border-color: #4a7c9e;
      background: white;
      box-shadow: 0 0 0 3px rgba(74, 124, 158, 0.1);
    }

    /* Custom Select Dropdown */
    .custom-select-wrapper {
      position: relative;
      width: 100%;
    }

    .custom-select-input {
      width: 100%;
      padding: 9px 40px 9px 12px;
      border: 1px solid #cbd5e0;
      border-radius: 4px;
      font-size: 13px;
      background: white;
      color: #2d3748;
      cursor: pointer;
      background-image: url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='%234a5568' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3e%3cpolyline points='6 9 12 15 18 9'%3e%3c/polyline%3e%3c/svg%3e");
      background-repeat: no-repeat;
      background-position: right 10px center;
      background-size: 14px;
      font-weight: 400;
    }

    .custom-select-input:focus {
      outline: none;
      border-color: #2196F3;
      box-shadow: 0 0 0 3px rgba(33, 150, 243, 0.1);
    }

    .custom-select-dropdown {
      position: absolute;
      top: 100%;
      left: 0;
      right: 0;
      background: white;
      border: 1px solid #cbd5e0;
      border-top: none;
      border-radius: 0 0 4px 4px;
      max-height: 250px;
      overflow-y: auto;
      z-index: 1000;
      display: none;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      margin-top: -1px;
    }

    .custom-select-dropdown.show {
      display: block;
    }

    .custom-select-option {
      padding: 10px 12px;
      cursor: pointer;
      font-size: 13px;
      color: #2d3748;
      transition: background 0.15s;
    }

    .custom-select-option:hover {
      background: #f7fafc;
    }

    .custom-select-option.selected {
      background: #e6f0f8;
      color: #2d4a68;
      font-weight: 500;
    }

    .custom-select-option.hidden {
      display: none;
    }

    .custom-select-option.disabled {
      color: #cbd5e0;
      cursor: not-allowed;
      background: #f9f9f9;
    }

    .custom-select-option.disabled:hover {
      background: #f9f9f9;
    }

    .custom-select-no-results {
      padding: 10px 12px;
      font-size: 13px;
      color: #999;
      text-align: center;
      font-style: italic;
    }

    .field-select {
      width: 100%;
      font-size: 12px;
    }

    .field-checkbox {
      display: flex;
      align-items: center;
      font-size: 12px;
      color: #555;
      margin-bottom: 12px;
      padding: 8px 10px;
      border-radius: 4px;
      cursor: pointer;
      transition: background 0.15s;
    }

    .field-checkbox:hover {
      background: #f5f5f5;
    }

    .field-checkbox input {
      margin-right: 10px;
      cursor: pointer;
      width: 16px;
      height: 16px;
    }

    .field-checkbox label {
      cursor: pointer;
      user-select: none;
    }

    .btn-close {
      padding: 6px 8px;
      border: none;
      border-radius: 4px;
      background: rgba(255,255,255,0.15);
      cursor: pointer;
      font-size: 14px;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.15s;
      color: white;
      width: 32px;
      height: 32px;
    }

    .btn-close:hover {
      background: rgba(255,255,255,0.25);
    }

    .sidebar-actions {
      margin-top: 20px;
      display: flex;
      gap: 10px;
      padding-top: 20px;
    }

    .btn-cancel {
      flex: 1;
      padding: 12px 20px;
      border-radius: 6px;
      border: 1px solid #cbd5e0;
      background: white;
      cursor: pointer;
      font-size: 13px;
      font-weight: 500;
      transition: all 0.15s;
      color: #4a5568;
    }

    .btn-cancel:hover {
      background: #f7fafc;
      border-color: #4a7c9e;
      color: #4a7c9e;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }

    .btn-primary {
      flex: 1;
      padding: 12px 20px;
      border-radius: 6px;
      border: 1px solid #4a7c9e;
      background: linear-gradient(135deg, #4a7c9e 0%, #3d6a8a 100%);
      cursor: pointer;
      font-size: 13px;
      font-weight: 500;
      transition: all 0.15s;
      color: white;
    }

    .btn-primary:hover {
      background: linear-gradient(135deg, #3d6a8a 0%, #2e5169 100%);
      box-shadow: 0 2px 4px rgba(0,0,0,0.15);
      transform: translateY(-1px);
    }

    .btn-primary:active {
      transform: translateY(0);
    }

    .field-hint {
      margin-top: 6px;
      font-size: 11px;
      color: #4a7c9e;
      font-style: italic;
      background: #e6f0f8;
      padding: 6px 10px;
      border-radius: 4px;
      border-left: 3px solid #4a7c9e;
    }

    .checkbox-group label {
      display: flex;
      align-items: center;
      margin-bottom: 10px;
      cursor: pointer;
      color: #2d3748;
      font-size: 13px;
      font-weight: 400;
    }

    .checkbox-group input[type="checkbox"] {
      margin-right: 8px;
      width: 16px;
      height: 16px;
      cursor: pointer;
      accent-color: #4a7c9e;
    }

    /* Legend Modal */
    .legend-modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.5);
      z-index: 1000;
      align-items: center;
      justify-content: center;
    }

    .legend-modal.open {
      display: flex;
    }

    .legend-modal-content {
      background: white;
      border-radius: 8px;
      width: 90%;
      max-width: 600px;
      max-height: 80vh;
      overflow-y: auto;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
    }

    .legend-modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 20px;
      border-bottom: 1px solid #e0e0e0;
      background: linear-gradient(135deg, #4a7c9e 0%, #3d6a8a 100%);
      border-radius: 8px 8px 0 0;
    }

    .legend-modal-header h2 {
      margin: 0;
      font-size: 18px;
      font-weight: 600;
      color: white;
    }

    .legend-close-btn {
      background: none;
      border: none;
      font-size: 24px;
      cursor: pointer;
      color: white;
      padding: 0;
      width: 30px;
      height: 30px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 4px;
      transition: background 0.2s;
    }

    .legend-close-btn:hover {
      background: rgba(255, 255, 255, 0.1);
    }

    .legend-modal-body {
      padding: 20px;
    }

    .legend-section {
      margin-bottom: 24px;
    }

    .legend-section:last-child {
      margin-bottom: 0;
    }

    .legend-section h3 {
      font-size: 14px;
      font-weight: 600;
      color: #333;
      margin-bottom: 12px;
      padding-bottom: 8px;
      border-bottom: 2px solid #e0e0e0;
    }

    .legend-item {
      display: flex;
      align-items: center;
      padding: 8px 0;
      gap: 12px;
    }

    .legend-icon {
      min-width: 30px;
      text-align: center;
      font-size: 16px;
      flex-shrink: 0;
    }

    .legend-description {
      flex: 1;
    }

    .legend-description strong {
      display: block;
      font-size: 13px;
      color: #333;
      margin-bottom: 2px;
    }

    .legend-description span {
      font-size: 12px;
      color: #666;
    }

    .btn-legend {
      background: linear-gradient(135deg, #4a7c9e 0%, #3d6a8a 100%);
      color: white;
      border: none;
      padding: 8px 16px;
      border-radius: 4px;
      font-size: 13px;
      cursor: pointer;
      transition: all 0.2s;
      margin-left: 8px;
    }

    .btn-legend:hover {
      background: linear-gradient(135deg, #3d6a8a 0%, #2d4a68 100%);
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
    }
  </style>
</head>
<body>
  <!-- Sidebar -->
  <div class="sidebar">
    <div class="logo">
      <div class="logo-icon">‚óà</div>
      <span>SPHERE</span>
    </div>
    <nav class="nav-menu">
      <div class="nav-item" onclick="window.location.href='/'">P&L View</div>
      <div class="nav-item active">Dimension Config</div>
      <div class="nav-item" onclick="window.location.href='/email-config'">Email Config</div>
      <div class="nav-item disabled">User Management</div>
    </nav>
  </div>

  <!-- Main Content -->
  <div class="main-content">
    <!-- Header Tabs -->
    <div class="header-tabs">
      <button class="tab active" data-dimension="account">Accounts</button>
      <button class="tab" data-dimension="customer">Customers</button>
      <button class="tab" data-dimension="department">Departments</button>
      <button class="tab" data-dimension="region">Regions</button>
      <button class="tab" data-dimension="vendor">Vendors</button>
    </div>

    <!-- Controls -->
    <div class="controls">
      <div class="search-box">
        <input 
          type="text" 
          id="searchInput" 
          placeholder="Search..."
        />
      </div>

      <button class="btn" onclick="expandAll()">Expand All</button>
      <button class="btn" onclick="collapseAll()">Collapse All</button>
      <button class="btn" style="background: #4CAF50; color: white;" onclick="addRootItem()">+ Add Root Item</button>
      <button class="btn" onclick="refreshDimensions()">Refresh</button>

      <div class="stats">
        <span>Total: <strong id="totalCount">0</strong></span>
        <span>Visible: <strong id="visibleCount">0</strong></span>
      </div>

      <button class="btn-legend" onclick="openLegendModal()">üìñ Legend</button>
    </div>

    <!-- Tree Content -->
    <div class="tree-content">
      <div id="loadingState" class="loading-state">Loading dimensions...</div>
      <div id="errorState" class="error-state" style="display: none;"></div>
      <ul id="treeRoot" class="tree-node" style="display: none;"></ul>
    </div>
  </div>

  <!-- Edit Sidebar -->
  <div id="editSidebar" class="edit-sidebar">
    <div class="edit-sidebar-header">
      <h3>Edit Item</h3>
      <button class="btn-close" onclick="closeEditSidebar()">‚úï</button>
    </div>

    <div class="edit-sidebar-content">
      <div class="field-group">
        <label class="field-label">Name</label>
        <input type="text" id="editName" class="field-input" placeholder="Enter name...">
      </div>

    <div id="accountMappingSection" class="field-group" style="display: none;">
      <label class="field-label">Map to Account</label>
      <div class="custom-select-wrapper">
        <input 
          type="text" 
          id="editAccountMapping" 
          class="custom-select-input" 
          placeholder="(No account mapped)"
          readonly
        />
        <div class="custom-select-dropdown" id="editAccountMappingDropdown"></div>
      </div>
      <div id="accountMappingHint" class="field-hint" style="display: none;"></div>
    </div>

      <div id="accountCheckboxesSection" class="field-group checkbox-group" style="display: none;">
        <label>
          <input type="checkbox" id="editDisplayExcluded">
          <span>Display Excluded</span>
        </label>

        <label>
          <input type="checkbox" id="editDoubleLines">
          <span>Double Lines</span>
        </label>

        <label>
          <input type="checkbox" id="editOperationalExcluded">
          <span>Operational Excluded</span>
        </label>
      </div>

      <!-- Customer Mapping Section -->
      <div id="customerMappingSection" class="field-group" style="display: none;">
        <label class="field-label">Map to Customer</label>
        <div class="custom-select-wrapper">
          <input 
            type="text" 
            id="editCustomerMapping" 
            class="custom-select-input" 
            placeholder="(No customer mapped)"
            readonly
          />
          <div class="custom-select-dropdown" id="editCustomerMappingDropdown"></div>
        </div>
        <div id="customerMappingHint" class="field-hint" style="display: none;"></div>
      </div>

      <!-- Customer Checkboxes -->
      <div id="customerCheckboxesSection" class="field-group checkbox-group" style="display: none;">
        <label>
          <input type="checkbox" id="editIsDistrict">
          <span>Mark as District</span>
        </label>

        <label id="districtReportingExcludedLabel" style="display: none; margin-left: 20px;">
          <input type="checkbox" id="editDistrictReportingExcluded">
          <span>Exclude District from Reporting</span>
        </label>
      </div>

      <!-- Start Date Field (Customers only) -->
      <div id="customerStartDateSection" class="field-group" style="display: none;">
        <label class="field-label">Start Date (Estimated)</label>
        <input type="date" id="editStartDate" class="field-input" readonly style="background-color: #f0f0f0; cursor: not-allowed;">
      </div>

      <!-- District Tags Section -->
      <div id="districtTagsSection" class="field-group" style="display: none;">
        <label class="field-label">District Tags</label>
        <div style="display: flex; gap: 6px; margin-bottom: 8px;">
          <input 
            type="text" 
            id="newDistrictTag" 
            class="field-input" 
            placeholder="Add district tag..."
            style="flex: 1;"
            onkeypress="if(event.key === 'Enter') { event.preventDefault(); addDistrictTag(); }"
          />
          <button class="btn" onclick="addDistrictTag()" style="padding: 6px 12px;">Add</button>
        </div>
        <div id="districtTagsList" style="display: flex; flex-wrap: wrap; gap: 4px;"></div>
      </div>

      <!-- Customer Tags Section -->
      <div id="customerTagsSection" class="field-group" style="display: none;">
        <label class="field-label">Customer Tags</label>
        <div style="display: flex; gap: 6px; margin-bottom: 8px;">
          <input 
            type="text" 
            id="newCustomerTag" 
            class="field-input" 
            placeholder="Add customer tag..."
            style="flex: 1;"
            onkeypress="if(event.key === 'Enter') { event.preventDefault(); addCustomerTag(); }"
          />
          <button class="btn" onclick="addCustomerTag()" style="padding: 6px 12px;">Add</button>
        </div>
        <div id="customerTagsList" style="display: flex; flex-wrap: wrap; gap: 4px;"></div>
      </div>

      <!-- Region Mapping Section -->
      <div id="regionMappingSection" class="field-group" style="display: none;">
        <label class="field-label">Map to NetSuite Region</label>
        <div class="custom-select-wrapper">
          <input 
            type="text" 
            id="editRegionMapping" 
            class="custom-select-input" 
            placeholder="(No region mapped)"
            readonly
          />
          <div class="custom-select-dropdown" id="editRegionMappingDropdown"></div>
        </div>
        <div id="regionMappingHint" class="field-hint" style="display: none;"></div>
      </div>

      <!-- Region Tags Section -->
      <div id="regionTagsSection" class="field-group" style="display: none;">
        <label class="field-label">Region Tags</label>
        <div style="display: flex; gap: 6px; margin-bottom: 8px;">
          <input 
            type="text" 
            id="newRegionTag" 
            class="field-input" 
            placeholder="Add region tag..."
            style="flex: 1;"
            onkeypress="if(event.key === 'Enter') { event.preventDefault(); addRegionTag(); }"
          />
          <button class="btn" onclick="addRegionTag()" style="padding: 6px 12px;">Add</button>
        </div>
        <div id="regionTagsList" style="display: flex; flex-wrap: wrap; gap: 4px;"></div>
      </div>

      <!-- Department/Subsidiary Mapping Section -->
      <div id="departmentMappingSection" class="field-group" style="display: none;">
        <label class="field-label">Map to NetSuite Subsidiary</label>
        <div class="custom-select-wrapper">
          <input 
            type="text" 
            id="editDepartmentMapping" 
            class="custom-select-input" 
            placeholder="(No subsidiary mapped)"
            readonly
          />
          <div class="custom-select-dropdown" id="editDepartmentMappingDropdown"></div>
        </div>
        <div id="departmentMappingHint" class="field-hint" style="display: none;"></div>
      </div>

      <!-- Department Tags Section -->
      <div id="departmentTagsSection" class="field-group" style="display: none;">
        <label class="field-label">Subsidiary Tags</label>
        <div style="display: flex; gap: 6px; margin-bottom: 8px;">
          <input 
            type="text" 
            id="newDepartmentTag" 
            class="field-input" 
            placeholder="Add subsidiary tag..."
            style="flex: 1;"
            onkeypress="if(event.key === 'Enter') { event.preventDefault(); addDepartmentTag(); }"
          />
          <button class="btn" onclick="addDepartmentTag()" style="padding: 6px 12px;">Add</button>
        </div>
        <div id="departmentTagsList" style="display: flex; flex-wrap: wrap; gap: 4px;"></div>
      </div>

      <div id="parentSection" class="field-group">
        <label class="field-label">Parent</label>
        <div class="custom-select-wrapper">
          <input 
            type="text" 
            id="editParent" 
            class="custom-select-input" 
            placeholder="(Root Level)"
            readonly
          />
          <div class="custom-select-dropdown" id="editParentDropdown"></div>
        </div>
      </div>

      <div class="sidebar-actions">
        <button class="btn-cancel" onclick="closeEditSidebar()">Cancel</button>
        <button class="btn-primary" onclick="saveChanges()">Save</button>
      </div>
    </div>
  </div>

  <!-- Legend Modal -->
  <div id="legendModal" class="legend-modal" onclick="closeLegendModal(event)">
    <div class="legend-modal-content" onclick="event.stopPropagation()">
      <div class="legend-modal-header">
        <h2>Icon Legend</h2>
        <button class="legend-close-btn" onclick="closeLegendModal()">‚úï</button>
      </div>
      <div class="legend-modal-body">
        
        <!-- Node Type Icons -->
        <div class="legend-section">
          <h3>Node Types</h3>
          <div class="legend-item">
            <div class="legend-icon">üè¢</div>
            <div class="legend-description">
              <strong>District</strong>
              <span>Indicates this is a district node (group of facilities)</span>
            </div>
          </div>
          <div class="legend-item">
            <div class="legend-icon">üë§</div>
            <div class="legend-description">
              <strong>Customer / Facility</strong>
              <span>Indicates this is a customer/facility node</span>
            </div>
          </div>
        </div>

        <!-- Status Icons -->
        <div class="legend-section">
          <h3>Mapping & Status</h3>
          <div class="legend-item">
            <div class="legend-icon" style="color: #2196F3; font-weight: bold;">‚ìÇÔ∏è</div>
            <div class="legend-description">
              <strong>Mapped</strong>
              <span>This item is mapped to the corresponding NetSuite dimension (required for P&L reporting)</span>
            </div>
          </div>
        </div>

        <!-- Exclusion Icons -->
        <div class="legend-section">
          <h3>Exclusions</h3>
          <div class="legend-item">
            <div class="legend-icon">üôà</div>
            <div class="legend-description">
              <strong>Display Excluded</strong>
              <span>Hidden from P&L display, but values are still included in totals</span>
            </div>
          </div>
          <div class="legend-item">
            <div class="legend-icon" style="color: #FF6F00; font-weight: bold;">‚äò</div>
            <div class="legend-description">
              <strong>Operational Excluded</strong>
              <span>When P&L type is "Operational", this account is completely excluded (not displayed and not included in totals). Still shows in "Standard" view.</span>
            </div>
          </div>
          <div class="legend-item">
            <div class="legend-icon" style="color: #D32F2F; font-weight: bold;">‚äñ</div>
            <div class="legend-description">
              <strong>District Reporting Excluded</strong>
              <span>Excluded from district-level reports (customers only)</span>
            </div>
          </div>
        </div>

        <!-- Display Options -->
        <div class="legend-section">
          <h3>Display Options</h3>
          <div class="legend-item">
            <div class="legend-icon" style="color: #9C27B0; font-weight: bold;">‚ò∞</div>
            <div class="legend-description">
              <strong>Double Lines</strong>
              <span>Adds a visual separator line after this account in P&L reports</span>
            </div>
          </div>
        </div>

        <!-- Navigation Icons -->
        <div class="legend-section">
          <h3>Navigation</h3>
          <div class="legend-item">
            <div class="legend-icon">‚ñ∂</div>
            <div class="legend-description">
              <strong>Collapsed</strong>
              <span>Click to expand and show child items</span>
            </div>
          </div>
          <div class="legend-item">
            <div class="legend-icon">‚ñº</div>
            <div class="legend-description">
              <strong>Expanded</strong>
              <span>Click to collapse and hide child items</span>
            </div>
          </div>
        </div>

        <!-- Tags -->
        <div class="legend-section">
          <h3>Tags</h3>
          <div class="legend-item">
            <div class="legend-icon" style="background: #ede7f6; padding: 2px 6px; border-radius: 3px; font-size: 10px; color: #4527a0;">D:Tag</div>
            <div class="legend-description">
              <strong>District Tag</strong>
              <span>Tag for grouping districts (purple background)</span>
            </div>
          </div>
          <div class="legend-item">
            <div class="legend-icon" style="background: #e8f5e9; padding: 2px 6px; border-radius: 3px; font-size: 10px; color: #1b5e20;">C:Tag</div>
            <div class="legend-description">
              <strong>Customer Tag</strong>
              <span>Tag for grouping customers/facilities (green background)</span>
            </div>
          </div>
          <div class="legend-item">
            <div class="legend-icon" style="background: #fff3e0; padding: 2px 6px; border-radius: 3px; font-size: 10px; color: #e65100;">S:Tag</div>
            <div class="legend-description">
              <strong>Subsidiary Tag</strong>
              <span>Tag for grouping subsidiaries (orange background)</span>
            </div>
          </div>
        </div>

      </div>
    </div>
  </div>

  <script>
    // State Management
    const AppState = {
      currentDimension: 'account',
      dimensions: {},
      expandedNodes: new Set(),
      searchQuery: '',
      trees: {},
      editingNode: null
    };

    // API Functions
    async function loadDimension(dimensionType) {
      const response = await fetch(`/api/config/${dimensionType}`);
      if (!response.ok) throw new Error(`Failed to load ${dimensionType}`);
      const data = await response.json();
      AppState.dimensions[dimensionType] = data;
      return data;
    }

    // Tree Building (using order field like Retool component)
    function buildTree(flatData) {
      if (!flatData) return [];
      
      const nodeMap = new Map();
      const childrenByParent = {};
      const roots = [];
      
      // Initialize all nodes
      for (const [id, data] of Object.entries(flatData)) {
        nodeMap.set(id, { id, ...data, children: [] });
      }
      
      // Collect children by parent, preserving order field
      for (const [id, node] of nodeMap) {
        const parentId = node.parent;
        
        // Determine order - use order field if available, otherwise use key-based order
        let order = node.order;
        if (order === undefined || order === null) {
          // Fallback: try to parse ID as number, otherwise use string comparison
          const numId = Number(id);
          order = isNaN(numId) ? id : numId;
        }
        
        if (parentId === null || parentId === undefined) {
          roots.push({ node, order });
        } else {
          if (!childrenByParent[parentId]) {
            childrenByParent[parentId] = [];
          }
          childrenByParent[parentId].push({ node, order });
        }
      }
      
      // Sort and assign children to parents
      for (const [parentId, children] of Object.entries(childrenByParent)) {
        children.sort((a, b) => {
          // Sort by order field (numeric comparison)
          if (typeof a.order === 'number' && typeof b.order === 'number') {
            return a.order - b.order;
          }
          // Fallback to string comparison if not numeric
          return String(a.order).localeCompare(String(b.order));
        });
        
        const parentNode = nodeMap.get(parentId);
        if (parentNode) {
          parentNode.children = children.map(c => c.node);
        }
      }
      
      // Sort root nodes by order
      roots.sort((a, b) => {
        if (typeof a.order === 'number' && typeof b.order === 'number') {
          return a.order - b.order;
        }
        return String(a.order).localeCompare(String(b.order));
      });
      
      return roots.map(r => r.node);
    }

    // Rendering
    function renderTree(tree, searchQuery = '') {
      const container = document.getElementById('treeRoot');
      container.innerHTML = '';
      
      if (!tree || tree.length === 0) {
        container.innerHTML = '<div class="empty-state">No data available</div>';
        container.style.display = 'block';
        hideLoadingState();
        return;
      }
      
      let visibleCount = 0;
      const totalCount = countNodes(tree);
      
      tree.forEach(node => {
        const nodeElement = renderNode(node, searchQuery, 0);
        if (nodeElement) {
          container.appendChild(nodeElement);
          visibleCount += countVisibleNodes(nodeElement);
        }
      });
      
      document.getElementById('totalCount').textContent = totalCount;
      document.getElementById('visibleCount').textContent = visibleCount;
      
      container.style.display = 'block';
      hideLoadingState();
    }

    function renderNode(node, searchQuery, level) {
      const matchesSearch = !searchQuery || 
        (node.label && node.label.toLowerCase().includes(searchQuery.toLowerCase())) ||
        (node.id && node.id.toLowerCase().includes(searchQuery.toLowerCase()));
      
      const childrenMatchSearch = searchQuery && node.children && 
        node.children.some(child => nodeMatchesSearchRecursive(child, searchQuery));
      
      if (searchQuery && !matchesSearch && !childrenMatchSearch) {
        return null;
      }
      
      const li = document.createElement('li');
      
      const div = document.createElement('div');
      div.className = 'node-item';
      div.style.paddingLeft = `${level * 12 + 6}px`;
      
      // Icon container
      const iconContainer = document.createElement('div');
      iconContainer.className = 'node-icon-container';
      
      const hasChildren = node.children && node.children.length > 0;
      if (hasChildren) {
        const isExpanded = AppState.expandedNodes.has(node.id) || searchQuery !== '';
        iconContainer.innerHTML = isExpanded ? 
          '<svg class="node-chevron" viewBox="0 0 24 24" fill="currentColor"><path d="M5 8h14l-7 11z" /></svg>' :
          '<svg class="node-chevron" viewBox="0 0 24 24" fill="currentColor"><path d="M8 5v14l11-7z" /></svg>';
        
        iconContainer.onclick = (e) => {
          e.stopPropagation();
          e.preventDefault();
          toggleNode(node.id);
        };
        iconContainer.style.cursor = 'pointer';
      }
      
      div.appendChild(iconContainer);
      
      // Label
      const label = document.createElement('span');
      label.className = 'node-label';
      
      // Add district icon
      if (node.isDistrict) {
        label.innerHTML += 'üè¢ ';
      }
      
      // Add customer icon (support both field names)
      if (node.customer_internal_id || node.customer_id) {
        label.innerHTML += 'üë§ ';
      }
      
      // Label text
      const labelText = document.createTextNode(node.label || node.id);
      label.appendChild(labelText);
      
      // Add mapping indicator (support both customer field names)
      if (node.account_internal_id || node.customer_internal_id || node.customer_id || 
          node.region_internal_id || node.subsidiary_internal_id || 
          node.vendor_internal_id) {
        const mappedIcon = document.createElement('span');
        mappedIcon.className = 'inline-icon';
        mappedIcon.innerHTML = '‚ìÇÔ∏è';
        mappedIcon.style.color = '#2196F3';
        mappedIcon.style.fontWeight = 'bold';
        mappedIcon.setAttribute('data-tooltip', 'Mapped to NetSuite: This item is mapped to the corresponding NetSuite dimension (required for P&L reporting)');
        label.appendChild(mappedIcon);
      }
      
      // Add exclusion indicators
      if (node.displayExcluded) {
        const icon = document.createElement('span');
        icon.className = 'inline-icon';
        icon.innerHTML = 'üôà';
        icon.setAttribute('data-tooltip', 'Display Excluded: Hidden from P&L display, but values are still included in totals');
        icon.style.opacity = '0.7';
        label.appendChild(icon);
      }
      
      if (node.doubleLines) {
        const icon = document.createElement('span');
        icon.className = 'inline-icon';
        icon.innerHTML = '‚ò∞';
        icon.setAttribute('data-tooltip', 'Double Lines: Adds a visual separator line above this account in P&L reports');
        icon.style.color = '#9C27B0';
        icon.style.fontWeight = 'bold';
        label.appendChild(icon);
      }
      
      if (node.operationalExcluded) {
        const icon = document.createElement('span');
        icon.className = 'inline-icon';
        icon.innerHTML = '‚äò';
        icon.setAttribute('data-tooltip', 'Operational Excluded: When P&L type is "Operational", this account is completely excluded (not displayed and not included in totals). Still shows in "Standard" view.');
        icon.style.color = '#FF6F00';
        icon.style.fontWeight = 'bold';
        label.appendChild(icon);
      }
      
      if (node.districtReportingExcluded) {
        const icon = document.createElement('span');
        icon.className = 'inline-icon';
        icon.innerHTML = '‚äñ';
        icon.setAttribute('data-tooltip', 'District Reporting Excluded: This customer is excluded from district-level reporting rollups');
        icon.style.color = '#D32F2F';
        icon.style.fontWeight = 'bold';
        label.appendChild(icon);
      }
      
      // Add tags
      if (AppState.currentDimension === 'customer') {
        if (node.districtTags && node.districtTags.length > 0) {
          node.districtTags.forEach(tag => {
            const tagSpan = document.createElement('span');
            tagSpan.className = 'tag tag-district';
            tagSpan.textContent = `D:${tag}`;
            label.appendChild(tagSpan);
          });
        }
        
        const customerTags = node.customerTags || node.tags || [];
        customerTags.forEach(tag => {
          const tagSpan = document.createElement('span');
          tagSpan.className = 'tag tag-customer';
          tagSpan.textContent = `C:${tag}`;
          label.appendChild(tagSpan);
        });
      } else if (AppState.currentDimension === 'department') {
        // Subsidiary tags
        if (node.tags && node.tags.length > 0) {
          node.tags.forEach(tag => {
            const tagSpan = document.createElement('span');
            tagSpan.className = 'tag tag-subsidiary';
            tagSpan.textContent = `S:${tag}`;
            label.appendChild(tagSpan);
          });
        }
      } else if (node.tags && node.tags.length > 0) {
        // Generic tags for other dimensions
        node.tags.forEach(tag => {
          const tagSpan = document.createElement('span');
          tagSpan.className = 'tag tag-generic';
          tagSpan.textContent = tag;
          label.appendChild(tagSpan);
        });
      }
      
      div.appendChild(label);
      
      // Add action buttons (drag handle + edit button)
      const actionsDiv = document.createElement('div');
      actionsDiv.className = 'node-actions';
      
      // Add drag handle (for accounts and customers tabs)
      if (AppState.currentDimension === 'account' || AppState.currentDimension === 'customer') {
        const dragHandle = document.createElement('button');
        dragHandle.className = 'btn-drag-handle';
        dragHandle.innerHTML = '‚ãÆ‚ãÆ';
        dragHandle.title = 'Drag to reorder';
        dragHandle.style.cursor = 'grab';
        dragHandle.draggable = true;
        
        // Store node data for drag/drop
        dragHandle.dataset.nodeId = node.id;
        dragHandle.dataset.parentId = node.parent || 'root';
        
        dragHandle.addEventListener('dragstart', (e) => {
          e.stopPropagation();
          dragHandle.style.cursor = 'grabbing';
          li.classList.add('dragging');
          e.dataTransfer.effectAllowed = 'move';
          e.dataTransfer.setData('text/plain', JSON.stringify({
            nodeId: node.id,
            parentId: node.parent || 'root'
          }));
        });
        
        dragHandle.addEventListener('dragend', (e) => {
          dragHandle.style.cursor = 'grab';
          li.classList.remove('dragging');
          document.querySelectorAll('.drag-over').forEach(el => el.classList.remove('drag-over'));
        });
        
        actionsDiv.appendChild(dragHandle);
      }
      
      // Add "+" button to create new child
      const addBtn = document.createElement('button');
      addBtn.className = 'btn-add-child';
      addBtn.innerHTML = '+';
      addBtn.title = 'Add child item';
      addBtn.onclick = (e) => {
        e.stopPropagation();
        addNewChild(node);
      };
      actionsDiv.appendChild(addBtn);
      
      const editBtn = document.createElement('button');
      editBtn.className = 'btn-edit';
      editBtn.innerHTML = '‚úèÔ∏è';
      editBtn.title = 'Edit';
      editBtn.onclick = (e) => {
        e.stopPropagation();
        openEditSidebar(node);
      };
      actionsDiv.appendChild(editBtn);
      
      // Add delete button
      const deleteBtn = document.createElement('button');
      deleteBtn.className = 'btn-delete';
      deleteBtn.innerHTML = 'üóëÔ∏è';
      deleteBtn.title = 'Delete';
      deleteBtn.onclick = (e) => {
        e.stopPropagation();
        deleteItem(node);
      };
      actionsDiv.appendChild(deleteBtn);
      
      div.appendChild(actionsDiv);
      
      li.appendChild(div);
      
      // Add drop handlers for reordering (for accounts and customers tabs)
      if (AppState.currentDimension === 'account' || AppState.currentDimension === 'customer') {
        li.dataset.nodeId = node.id;
        li.dataset.parentId = node.parent || 'root';
        
        li.addEventListener('dragover', (e) => {
          e.preventDefault();
          e.stopPropagation();
          
          const draggingElement = document.querySelector('.dragging');
          if (!draggingElement) return;
          
          // Only allow drop if same parent
          const dragData = e.dataTransfer.types.includes('text/plain');
          if (dragData && li !== draggingElement) {
            li.classList.add('drag-over');
          }
        });
        
        li.addEventListener('dragleave', (e) => {
          e.preventDefault();
          li.classList.remove('drag-over');
        });
        
        li.addEventListener('drop', (e) => {
          e.preventDefault();
          e.stopPropagation();
          li.classList.remove('drag-over');
          
          try {
            const dragData = JSON.parse(e.dataTransfer.getData('text/plain'));
            const draggedNodeId = dragData.nodeId;
            const draggedParentId = dragData.parentId;
            const dropTargetParentId = node.parent || 'root';
            
            // Only allow reordering within same parent
            if (draggedParentId !== dropTargetParentId) {
              console.log('Cannot reorder across different parents');
              return;
            }
            
            if (draggedNodeId === node.id) {
              return; // Dropping on itself
            }
            
            // Reorder the nodes
            reorderNodes(draggedNodeId, node.id, dropTargetParentId);
          } catch (error) {
            console.error('Error handling drop:', error);
          }
        });
      }
      
      // Children
      if (hasChildren) {
        const childrenContainer = document.createElement('ul');
        childrenContainer.className = 'node-children';
        
        const isExpanded = AppState.expandedNodes.has(node.id) || searchQuery !== '';
        if (isExpanded) {
          childrenContainer.classList.add('expanded');
        }
        
        node.children.forEach(child => {
          const childElement = renderNode(child, searchQuery, level + 1);
          if (childElement) {
            childrenContainer.appendChild(childElement);
          }
        });
        
        li.appendChild(childrenContainer);
      }
      
      return li;
    }

    function reorderNodes(draggedId, targetId, parentId) {
      const currentData = AppState.dimensions[AppState.currentDimension];
      if (!currentData) return;
      
      // Get all siblings (nodes with the same parent), sorted by current order
      const siblings = Object.entries(currentData)
        .filter(([id, data]) => (data.parent || 'root') === parentId)
        .map(([id, data]) => ({ id, data, order: data.order }))
        .sort((a, b) => {
          if (typeof a.order === 'number' && typeof b.order === 'number') {
            return a.order - b.order;
          }
          return String(a.order || a.id).localeCompare(String(b.order || b.id));
        });
      
      // Find indices
      const draggedIndex = siblings.findIndex(s => s.id === draggedId);
      const targetIndex = siblings.findIndex(s => s.id === targetId);
      
      if (draggedIndex === -1 || targetIndex === -1) return;
      
      // Remove dragged item and insert at target position
      const [draggedItem] = siblings.splice(draggedIndex, 1);
      siblings.splice(targetIndex, 0, draggedItem);
      
      // Update order for all siblings
      siblings.forEach((sibling, index) => {
        currentData[sibling.id].order = index;
      });
      
      // Rebuild tree with new order and re-render
      AppState.trees[AppState.currentDimension] = buildTree(currentData);
      renderCurrentDimension();
      
      // Auto-save the changes
      saveConfigurationSilently();
    }
    
    async function saveConfigurationSilently() {
      const currentData = AppState.dimensions[AppState.currentDimension];
      if (!currentData) return;
      
      try {
        const response = await fetch(`/api/config/${AppState.currentDimension}`, {
          method: 'PUT',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(currentData),
        });
        
        if (response.ok) {
          console.log('‚úÖ Configuration auto-saved after reorder');
        } else {
          const errorData = await response.json();
          console.error('Failed to auto-save:', errorData);
        }
      } catch (error) {
        console.error('Error auto-saving configuration:', error);
      }
    }

    function toggleNode(nodeId) {
      if (AppState.expandedNodes.has(nodeId)) {
        AppState.expandedNodes.delete(nodeId);
      } else {
        AppState.expandedNodes.add(nodeId);
      }
      renderCurrentDimension();
    }

    function expandAll() {
      const currentData = AppState.dimensions[AppState.currentDimension];
      if (!currentData) return;
      
      for (const id of Object.keys(currentData)) {
        AppState.expandedNodes.add(id);
      }
      renderCurrentDimension();
    }

    function collapseAll() {
      AppState.expandedNodes.clear();
      renderCurrentDimension();
    }

    function nodeMatchesSearchRecursive(node, query) {
      if ((node.label && node.label.toLowerCase().includes(query.toLowerCase())) ||
          (node.id && node.id.toLowerCase().includes(query.toLowerCase()))) {
        return true;
      }
      
      if (node.children) {
        return node.children.some(child => nodeMatchesSearchRecursive(child, query));
      }
      
      return false;
    }

    function countNodes(tree) {
      let count = 0;
      
      function countRecursive(nodes) {
        nodes.forEach(node => {
          count++;
          if (node.children) {
            countRecursive(node.children);
          }
        });
      }
      
      countRecursive(tree);
      return count;
    }

    function countVisibleNodes(element) {
      let count = 1;
      
      const childrenContainer = element.querySelector('.node-children');
      if (childrenContainer) {
        const children = childrenContainer.querySelectorAll(':scope > li');
        children.forEach(child => {
          count += countVisibleNodes(child);
        });
      }
      
      return count;
    }

    function showLoadingState() {
      document.getElementById('loadingState').style.display = 'block';
      document.getElementById('errorState').style.display = 'none';
      document.getElementById('treeRoot').style.display = 'none';
    }

    function hideLoadingState() {
      document.getElementById('loadingState').style.display = 'none';
    }

    function showErrorState(message) {
      const errorState = document.getElementById('errorState');
      errorState.textContent = `Error: ${message}`;
      errorState.style.display = 'block';
      document.getElementById('loadingState').style.display = 'none';
      document.getElementById('treeRoot').style.display = 'none';
    }

    async function switchDimension(dimensionType) {
      AppState.currentDimension = dimensionType;
      showLoadingState();
      
      try {
        if (!AppState.dimensions[dimensionType]) {
          await loadDimension(dimensionType);
        }
        
        // Auto-expand all on initial load
        if (!AppState.trees[dimensionType]) {
          const data = AppState.dimensions[dimensionType];
          if (data) {
            for (const id of Object.keys(data)) {
              AppState.expandedNodes.add(id);
            }
          }
        }
        
        renderCurrentDimension();
      } catch (error) {
        showErrorState(error.message);
      }
    }

    function renderCurrentDimension() {
      const data = AppState.dimensions[AppState.currentDimension];
      
      if (!data) {
        showErrorState('No data available');
        return;
      }
      
      if (!AppState.trees[AppState.currentDimension]) {
        AppState.trees[AppState.currentDimension] = buildTree(data);
      }
      
      const tree = AppState.trees[AppState.currentDimension];
      renderTree(tree, AppState.searchQuery);
    }

    async function refreshDimensions() {
      showLoadingState();
      
      try {
        AppState.dimensions[AppState.currentDimension] = null;
        AppState.trees[AppState.currentDimension] = null;
        
        await loadDimension(AppState.currentDimension);
        renderCurrentDimension();
      } catch (error) {
        showErrorState(error.message);
      }
    }

    // Legend Modal Functions
    function openLegendModal() {
      const modal = document.getElementById('legendModal');
      modal.classList.add('open');
      // Prevent body scroll when modal is open
      document.body.style.overflow = 'hidden';
    }

    function closeLegendModal(event) {
      // Close if clicking outside the modal content or on close button
      if (!event || event.target === event.currentTarget || event.target.classList.contains('legend-close-btn')) {
        const modal = document.getElementById('legendModal');
        modal.classList.remove('open');
        // Re-enable body scroll
        document.body.style.overflow = '';
      }
    }

    // Close modal on Escape key
    document.addEventListener('keydown', function(e) {
      if (e.key === 'Escape') {
        closeLegendModal();
      }
    });

    // Event Listeners
    document.querySelectorAll('.tab').forEach(tab => {
      tab.addEventListener('click', function() {
        document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
        this.classList.add('active');
        
        const dimensionType = this.dataset.dimension;
        switchDimension(dimensionType);
      });
    });

    let searchTimeout;
    document.getElementById('searchInput').addEventListener('input', function(e) {
      clearTimeout(searchTimeout);
      searchTimeout = setTimeout(() => {
        AppState.searchQuery = e.target.value.trim();
        
        if (AppState.searchQuery) {
          expandAll();
        }
        
        renderCurrentDimension();
      }, 300);
    });

    document.querySelectorAll('.nav-item:not(.disabled)').forEach(item => {
      item.addEventListener('click', function() {
        if (this.textContent === 'P&L View') {
          window.location.href = '/';
        }
      });
    });

    // Add Root Item Function
    function addRootItem() {
      const dimension = AppState.currentDimension;
      const configData = AppState.dimensions[dimension];
      
      // Generate unique ID (timestamp-based)
      const timestamp = Date.now();
      const randomSuffix = Math.floor(Math.random() * 1000);
      const newId = `new_${timestamp}_${randomSuffix}`;
      
      // Determine label based on dimension
      let labelPrefix = 'New Item';
      if (dimension === 'account') labelPrefix = 'New Account';
      else if (dimension === 'customer') labelPrefix = 'New Customer';
      else if (dimension === 'department') labelPrefix = 'New Subsidiary';
      else if (dimension === 'region') labelPrefix = 'New Region';
      else if (dimension === 'vendor') labelPrefix = 'New Vendor';
      
      // Create new root node with default properties
      const newNode = {
        id: newId,
        label: labelPrefix,
        parent: null, // Root level
        order: 999999 // Place at end by default
      };
      
      // Add dimension-specific defaults
      if (dimension === 'customer') {
        newNode.isDistrict = false;
        newNode.districtReportingExcluded = false;
        newNode.districtTags = [];
        newNode.customerTags = [];
      } else if (dimension === 'account') {
        newNode.displayExcluded = false;
        newNode.operationalExcluded = false;
        newNode.doubleLines = false;
      } else if (dimension === 'department') {
        newNode.tags = [];
      } else if (dimension === 'region') {
        newNode.tags = [];
      }
      
      // Add to config data
      configData[newId] = newNode;
      
      // Re-render the tree
      const tree = buildTree(AppState.dimensions[dimension]);
      renderTree(tree, AppState.searchQuery);
      
      // Open edit sidebar for the new node
      openEditSidebar(newNode);
    }

    // Delete Item Function
    async function deleteItem(node) {
      const dimension = AppState.currentDimension;
      const configData = AppState.dimensions[dimension];
      
      // Check if node has children
      const hasChildren = node.children && node.children.length > 0;
      
      // Confirmation message
      let confirmMessage = `Are you sure you want to delete "${node.label || node.id}"?`;
      if (hasChildren) {
        confirmMessage = `"${node.label || node.id}" has ${node.children.length} child item(s).\n\nDeleting this item will also delete all its children.\n\nAre you sure you want to continue?`;
      }
      
      if (!confirm(confirmMessage)) {
        return; // User cancelled
      }
      
      // Function to recursively delete node and its children
      function deleteNodeAndChildren(nodeToDelete) {
        // Delete all children first
        if (nodeToDelete.children && nodeToDelete.children.length > 0) {
          nodeToDelete.children.forEach(child => {
            deleteNodeAndChildren(child);
          });
        }
        
        // Delete the node itself
        delete configData[nodeToDelete.id];
      }
      
      // Delete the node and all its children
      deleteNodeAndChildren(node);
      
      // Close edit sidebar if this node was being edited
      if (AppState.editingNode && AppState.editingNode.id === node.id) {
        closeEditSidebar();
      }
      
      // Re-render the tree
      const tree = buildTree(AppState.dimensions[dimension]);
      renderTree(tree, AppState.searchQuery);
      
      // Save to server
      try {
        const response = await fetch(`/api/config/${dimension}`, {
          method: 'PUT',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(configData)
        });
        
        if (!response.ok) {
          throw new Error('Failed to save after deletion');
        }
        
        console.log(`Successfully deleted ${node.label || node.id}`);
      } catch (error) {
        console.error('Error saving after deletion:', error);
        alert('Item deleted locally but failed to save to server. Please refresh and try again.');
      }
    }

    // Add New Child Function
    function addNewChild(parentNode) {
      const dimension = AppState.currentDimension;
      const configData = AppState.dimensions[dimension];
      
      // Generate unique ID (timestamp-based)
      const timestamp = Date.now();
      const randomSuffix = Math.floor(Math.random() * 1000);
      const newId = `new_${timestamp}_${randomSuffix}`;
      
      // Determine label based on dimension
      let labelPrefix = 'New Item';
      if (dimension === 'account') labelPrefix = 'New Account';
      else if (dimension === 'customer') labelPrefix = 'New Customer';
      else if (dimension === 'department') labelPrefix = 'New Subsidiary';
      else if (dimension === 'region') labelPrefix = 'New Region';
      else if (dimension === 'vendor') labelPrefix = 'New Vendor';
      
      // Create new node with default properties
      const newNode = {
        id: newId,
        label: labelPrefix,
        parent: parentNode.id,
        order: 999999 // Place at end by default
      };
      
      // Add dimension-specific defaults
      if (dimension === 'customer') {
        newNode.isDistrict = false;
        newNode.districtReportingExcluded = false;
        newNode.districtTags = [];
        newNode.customerTags = [];
      } else if (dimension === 'account') {
        newNode.displayExcluded = false;
        newNode.operationalExcluded = false;
        newNode.doubleLines = false;
      } else if (dimension === 'department') {
        newNode.tags = [];
      } else if (dimension === 'region') {
        newNode.tags = [];
      }
      
      // Add to config data
      configData[newId] = newNode;
      
      // Expand the parent node so the new child is visible
      AppState.expandedNodes.add(parentNode.id);
      
      // Re-render the tree
      const tree = buildTree(AppState.dimensions[dimension]);
      renderTree(tree, AppState.searchQuery);
      
      // Open edit sidebar for the new node
      openEditSidebar(newNode);
    }

    // Edit Sidebar Functions
    async function openEditSidebar(node) {
      AppState.editingNode = node;
      
      // Populate fields
      document.getElementById('editName').value = node.label || '';
      
      // Show/hide sections based on dimension type
      const isAccountTab = AppState.currentDimension === 'account';
      const isCustomerTab = AppState.currentDimension === 'customer';
      const isRegionTab = AppState.currentDimension === 'region';
      const isDepartmentTab = AppState.currentDimension === 'department';
      
      document.getElementById('accountMappingSection').style.display = isAccountTab ? 'block' : 'none';
      document.getElementById('accountCheckboxesSection').style.display = isAccountTab ? 'block' : 'none';
      
      document.getElementById('customerMappingSection').style.display = isCustomerTab ? 'block' : 'none';
      document.getElementById('customerCheckboxesSection').style.display = isCustomerTab ? 'block' : 'none';
      document.getElementById('customerStartDateSection').style.display = isCustomerTab ? 'block' : 'none';
      document.getElementById('districtTagsSection').style.display = isCustomerTab ? 'block' : 'none';
      document.getElementById('customerTagsSection').style.display = isCustomerTab ? 'block' : 'none';
      
      document.getElementById('regionMappingSection').style.display = isRegionTab ? 'block' : 'none';
      document.getElementById('regionTagsSection').style.display = isRegionTab ? 'block' : 'none';
      
      document.getElementById('departmentMappingSection').style.display = isDepartmentTab ? 'block' : 'none';
      document.getElementById('departmentTagsSection').style.display = isDepartmentTab ? 'block' : 'none';
      
      // Hide parent section for department tab (subsidiaries are managed in BigQuery)
      document.getElementById('parentSection').style.display = isDepartmentTab ? 'none' : 'block';
      
      if (isAccountTab) {
        // Populate account mapping dropdown (async)
        await populateAccountMappingDropdown(node);
        
        // Set checkboxes
        document.getElementById('editDisplayExcluded').checked = node.displayExcluded || false;
        document.getElementById('editDoubleLines').checked = node.doubleLines || false;
        document.getElementById('editOperationalExcluded').checked = node.operationalExcluded || false;
      }
      
      if (isCustomerTab) {
        // Populate customer mapping dropdown (async)
        await populateCustomerMappingDropdown(node);
        
        // Set customer checkboxes
        const isDistrict = node.isDistrict || false;
        document.getElementById('editIsDistrict').checked = isDistrict;
        document.getElementById('editDistrictReportingExcluded').checked = node.districtReportingExcluded || false;
        
        // Show/hide district reporting excluded checkbox based on isDistrict
        const districtReportingLabel = document.getElementById('districtReportingExcludedLabel');
        districtReportingLabel.style.display = isDistrict ? 'block' : 'none';
        
        // Set start date
        document.getElementById('editStartDate').value = node.start_date_est || '';
        
        // Populate tags
        populateDistrictTags(node.districtTags || []);
        populateCustomerTags(node.customerTags || node.tags || []);
        
        // Setup isDistrict checkbox listener
        document.getElementById('editIsDistrict').onchange = function(e) {
          const isChecked = e.target.checked;
          districtReportingLabel.style.display = isChecked ? 'block' : 'none';
          if (!isChecked) {
            document.getElementById('editDistrictReportingExcluded').checked = false;
          }
        };
      }
      
      if (isRegionTab) {
        // Populate region mapping dropdown (async)
        await populateRegionMappingDropdown(node);
        
        // Populate tags
        populateRegionTags(node.tags || []);
      }
      
      if (isDepartmentTab) {
        // Populate department mapping dropdown (async)
        await populateDepartmentMappingDropdown(node);
        
        // Populate tags
        populateDepartmentTags(node.tags || []);
      }
      
      // Populate parent dropdown (except for department/subsidiary)
      if (!isDepartmentTab) {
        populateParentDropdown(node);
      }
      
      // Show sidebar
      document.getElementById('editSidebar').classList.add('open');
    }

    function closeEditSidebar() {
      AppState.editingNode = null;
      document.getElementById('editSidebar').classList.remove('open');
    }

    async function saveChanges() {
      if (!AppState.editingNode) {
        console.error('No node being edited');
        return;
      }

      const node = AppState.editingNode;
      const nodeId = node.id;
      const dimension = AppState.currentDimension;
      
      // Get updated values from form
      const newLabel = document.getElementById('editName').value.trim();
      if (!newLabel) {
        alert('Name cannot be empty');
        return;
      }

      // Get parent value
      const parentInput = document.getElementById('editParent');
      const newParent = parentInput.dataset.selectedValue || null;

      // Update node in AppState
      const configData = AppState.dimensions[dimension];
      if (!configData[nodeId]) {
        console.error('Node not found in config:', nodeId);
        return;
      }

      // Update label
      configData[nodeId].label = newLabel;
      
      // Update parent (except for department/subsidiary which is managed in BigQuery)
      if (dimension !== 'department') {
        configData[nodeId].parent = newParent;
      }

      // For Account tab, update account-specific fields
      if (dimension === 'account') {
        // Get account mapping value
        const accountMappingInput = document.getElementById('editAccountMapping');
        const accountMappingValue = accountMappingInput.dataset.selectedValue;
        if (accountMappingValue) {
          configData[nodeId].account_internal_id = accountMappingValue;
        } else {
          delete configData[nodeId].account_internal_id;
        }

        // Get checkbox values
        configData[nodeId].displayExcluded = document.getElementById('editDisplayExcluded').checked;
        configData[nodeId].doubleLines = document.getElementById('editDoubleLines').checked;
        configData[nodeId].operationalExcluded = document.getElementById('editOperationalExcluded').checked;
      }

      // For Customer tab, update customer-specific fields
      if (dimension === 'customer') {
        // Get customer mapping value
        const customerMappingInput = document.getElementById('editCustomerMapping');
        const customerMappingValue = customerMappingInput.dataset.selectedValue;
        const customerDisplayName = customerMappingInput.dataset.selectedDisplayName;
        
        if (customerMappingValue) {
          // Save as customer_internal_id to match config structure
          configData[nodeId].customer_internal_id = parseInt(customerMappingValue);
          if (customerDisplayName) {
            configData[nodeId].customer_display_name = customerDisplayName;
          }
        } else {
          delete configData[nodeId].customer_internal_id;
          delete configData[nodeId].customer_id; // Clean up old field name too
          delete configData[nodeId].customer_display_name;
        }

        // Get checkbox values
        configData[nodeId].isDistrict = document.getElementById('editIsDistrict').checked;
        configData[nodeId].districtReportingExcluded = document.getElementById('editDistrictReportingExcluded').checked;

        // Start date is read-only, so we don't update it here
        // It will be preserved from the original data

        // Get tags from the editing node (which were updated by add/remove functions)
        configData[nodeId].districtTags = node.districtTags || [];
        configData[nodeId].customerTags = node.customerTags || [];
      }

      // For Region tab, update region-specific fields
      if (dimension === 'region') {
        const regionMappingInput = document.getElementById('editRegionMapping');
        const regionMappingValue = regionMappingInput.dataset.selectedValue;
        
        if (regionMappingValue) {
          configData[nodeId].region_internal_id = parseInt(regionMappingValue);
        } else {
          delete configData[nodeId].region_internal_id;
        }

        // Save tags
        configData[nodeId].tags = node.tags || [];
      }

      // For Department tab, update department-specific fields
      if (dimension === 'department') {
        const departmentMappingInput = document.getElementById('editDepartmentMapping');
        const departmentMappingValue = departmentMappingInput.dataset.selectedValue;
        
        if (departmentMappingValue) {
          configData[nodeId].subsidiary_internal_id = parseInt(departmentMappingValue);
        } else {
          delete configData[nodeId].subsidiary_internal_id;
        }

        // Save tags
        configData[nodeId].tags = node.tags || [];
      }

      // Save to backend
      try {
        const response = await fetch(`/api/config/${dimension}`, {
          method: 'PUT',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(configData)
        });

        if (!response.ok) {
          throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }

        const result = await response.json();
        if (result.success) {
          console.log('‚úÖ Configuration saved successfully');
          
          // Rebuild tree from updated data and re-render
          AppState.trees[dimension] = buildTree(configData);
          renderTree(AppState.trees[dimension], AppState.searchQuery);
          
          // Close sidebar
          closeEditSidebar();
        } else {
          throw new Error('Save failed');
        }
      } catch (error) {
        console.error('Error saving configuration:', error);
        alert(`Failed to save: ${error.message}`);
      }
    }

    // Tag management functions
    function populateDistrictTags(tags) {
      const container = document.getElementById('districtTagsList');
      container.innerHTML = '';
      
      tags.forEach(tag => {
        const tagSpan = document.createElement('span');
        tagSpan.style.cssText = 'font-size: 10px; padding: 4px 8px; border-radius: 12px; background-color: #ede7f6; color: #4527a0; display: inline-flex; align-items: center; gap: 4px;';
        
        const tagText = document.createTextNode(`D:${tag} `);
        tagSpan.appendChild(tagText);
        
        const closeBtn = document.createElement('span');
        closeBtn.style.cssText = 'cursor: pointer; font-weight: bold;';
        closeBtn.textContent = '√ó';
        closeBtn.onclick = () => removeDistrictTag(tag);
        
        tagSpan.appendChild(closeBtn);
        container.appendChild(tagSpan);
      });
    }
    
    function populateCustomerTags(tags) {
      const container = document.getElementById('customerTagsList');
      container.innerHTML = '';
      
      tags.forEach(tag => {
        const tagSpan = document.createElement('span');
        tagSpan.style.cssText = 'font-size: 10px; padding: 4px 8px; border-radius: 12px; background-color: #e8f5e9; color: #1b5e20; display: inline-flex; align-items: center; gap: 4px;';
        
        const tagText = document.createTextNode(`C:${tag} `);
        tagSpan.appendChild(tagText);
        
        const closeBtn = document.createElement('span');
        closeBtn.style.cssText = 'cursor: pointer; font-weight: bold;';
        closeBtn.textContent = '√ó';
        closeBtn.onclick = () => removeCustomerTag(tag);
        
        tagSpan.appendChild(closeBtn);
        container.appendChild(tagSpan);
      });
    }
    
    function addDistrictTag() {
      const input = document.getElementById('newDistrictTag');
      const tag = input.value.trim();
      
      if (!tag) return;
      
      // Get current tags
      const node = AppState.editingNode;
      if (!node) return;
      
      const currentTags = node.districtTags || [];
      if (currentTags.includes(tag)) {
        alert('This tag already exists');
        return;
      }
      
      // Add tag
      const newTags = [...currentTags, tag];
      node.districtTags = newTags;
      
      // Update display
      populateDistrictTags(newTags);
      input.value = '';
    }
    
    function removeDistrictTag(tagToRemove) {
      const node = AppState.editingNode;
      if (!node) return;
      
      const currentTags = node.districtTags || [];
      const newTags = currentTags.filter(t => t !== tagToRemove);
      node.districtTags = newTags;
      
      populateDistrictTags(newTags);
    }
    
    function addCustomerTag() {
      const input = document.getElementById('newCustomerTag');
      const tag = input.value.trim();
      
      if (!tag) return;
      
      // Get current tags
      const node = AppState.editingNode;
      if (!node) return;
      
      const currentTags = node.customerTags || node.tags || [];
      if (currentTags.includes(tag)) {
        alert('This tag already exists');
        return;
      }
      
      // Add tag
      const newTags = [...currentTags, tag];
      node.customerTags = newTags;
      
      // Update display
      populateCustomerTags(newTags);
      input.value = '';
    }
    
    function removeCustomerTag(tagToRemove) {
      const node = AppState.editingNode;
      if (!node) return;
      
      const currentTags = node.customerTags || node.tags || [];
      const newTags = currentTags.filter(t => t !== tagToRemove);
      node.customerTags = newTags;
      
      populateCustomerTags(newTags);
    }

    // Region tag management functions
    function populateRegionTags(tags) {
      const container = document.getElementById('regionTagsList');
      container.innerHTML = '';
      
      tags.forEach(tag => {
        const tagSpan = document.createElement('span');
        tagSpan.style.cssText = 'font-size: 10px; padding: 4px 8px; border-radius: 12px; background-color: #e3f2fd; color: #0d47a1; display: inline-flex; align-items: center; gap: 4px;';
        
        const tagText = document.createTextNode(`R:${tag} `);
        tagSpan.appendChild(tagText);
        
        const closeBtn = document.createElement('span');
        closeBtn.style.cssText = 'cursor: pointer; font-weight: bold;';
        closeBtn.textContent = '√ó';
        closeBtn.onclick = () => removeRegionTag(tag);
        
        tagSpan.appendChild(closeBtn);
        container.appendChild(tagSpan);
      });
    }
    
    function addRegionTag() {
      const input = document.getElementById('newRegionTag');
      const tag = input.value.trim();
      
      if (!tag) return;
      
      const node = AppState.editingNode;
      if (!node) return;
      
      const currentTags = node.tags || [];
      if (currentTags.includes(tag)) {
        alert('This tag already exists');
        return;
      }
      
      const newTags = [...currentTags, tag];
      node.tags = newTags;
      
      populateRegionTags(newTags);
      input.value = '';
    }
    
    function removeRegionTag(tagToRemove) {
      const node = AppState.editingNode;
      if (!node) return;
      
      const currentTags = node.tags || [];
      const newTags = currentTags.filter(t => t !== tagToRemove);
      node.tags = newTags;
      
      populateRegionTags(newTags);
    }

    // Department/Subsidiary tag management functions
    function populateDepartmentTags(tags) {
      const container = document.getElementById('departmentTagsList');
      container.innerHTML = '';
      
      tags.forEach(tag => {
        const tagSpan = document.createElement('span');
        tagSpan.style.cssText = 'font-size: 10px; padding: 4px 8px; border-radius: 12px; background-color: #fff3e0; color: #e65100; display: inline-flex; align-items: center; gap: 4px;';
        
        const tagText = document.createTextNode(`S:${tag} `);
        tagSpan.appendChild(tagText);
        
        const closeBtn = document.createElement('span');
        closeBtn.style.cssText = 'cursor: pointer; font-weight: bold;';
        closeBtn.textContent = '√ó';
        closeBtn.onclick = () => removeDepartmentTag(tag);
        
        tagSpan.appendChild(closeBtn);
        container.appendChild(tagSpan);
      });
    }
    
    function addDepartmentTag() {
      const input = document.getElementById('newDepartmentTag');
      const tag = input.value.trim();
      
      if (!tag) return;
      
      const node = AppState.editingNode;
      if (!node) return;
      
      const currentTags = node.tags || [];
      if (currentTags.includes(tag)) {
        alert('This tag already exists');
        return;
      }
      
      const newTags = [...currentTags, tag];
      node.tags = newTags;
      
      populateDepartmentTags(newTags);
      input.value = '';
    }
    
    function removeDepartmentTag(tagToRemove) {
      const node = AppState.editingNode;
      if (!node) return;
      
      const currentTags = node.tags || [];
      const newTags = currentTags.filter(t => t !== tagToRemove);
      node.tags = newTags;
      
      populateDepartmentTags(newTags);
    }

    // Customer mapping dropdown
    async function populateCustomerMappingDropdown(node) {
      const input = document.getElementById('editCustomerMapping');
      const dropdown = document.getElementById('editCustomerMappingDropdown');
      const hint = document.getElementById('customerMappingHint');
      
      // Clear existing options
      dropdown.innerHTML = '';
      
      // Show loading state
      const loadingOption = document.createElement('div');
      loadingOption.className = 'custom-select-no-results';
      loadingOption.textContent = 'Loading customers...';
      dropdown.appendChild(loadingOption);
      
      try {
        // Fetch customers from API
        const response = await fetch('/api/customers');
        if (!response.ok) {
          throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        const customers = await response.json();
        
        // Clear loading state
        dropdown.innerHTML = '';
        
        // Create "No customer mapped" option
        const noMapOption = document.createElement('div');
        noMapOption.className = 'custom-select-option';
        noMapOption.textContent = '(No customer mapped)';
        noMapOption.dataset.value = '';
        dropdown.appendChild(noMapOption);
        
        // Get all already-mapped customer IDs (excluding current node)
        const currentData = AppState.dimensions[AppState.currentDimension];
        const mappedCustomerIds = new Set();
        
        for (const [itemId, itemData] of Object.entries(currentData)) {
          if (itemId !== node.id) {
            const custId = itemData.customer_internal_id || itemData.customer_id;
            if (custId) {
              mappedCustomerIds.add(parseInt(custId));
            }
          }
        }
        
        // Add all customer options
        let selectedText = '';
        let selectedDisplayName = '';
        const nodeCustomerId = node.customer_internal_id || node.customer_id;
        
        customers.forEach(customer => {
          const option = document.createElement('div');
          option.className = 'custom-select-option';
          const baseText = customer.display_name_with_id || `${customer.display_name} (${customer.customer_id})`;
          option.textContent = baseText;
          option.dataset.value = customer.customer_id;
          option.dataset.displayName = customer.display_name;
          
          // Check if this is the currently selected customer
          const isCurrentSelection = nodeCustomerId && parseInt(nodeCustomerId) === parseInt(customer.customer_id);
          
          // Check if this customer is already mapped to another item
          const isAlreadyMapped = mappedCustomerIds.has(parseInt(customer.customer_id));
          
          if (isAlreadyMapped) {
            option.classList.add('disabled');
            option.textContent += ' (already mapped)';
          }
          
          if (isCurrentSelection) {
            option.classList.add('selected');
            selectedText = baseText;
            selectedDisplayName = customer.display_name;
          }
          
          dropdown.appendChild(option);
        });
        
        // Set input value and hint
        if (nodeCustomerId && selectedText) {
          input.value = selectedText;
          input.dataset.selectedValue = nodeCustomerId;
          input.dataset.selectedDisplayName = selectedDisplayName;
          hint.textContent = `Mapped to customer ID: ${nodeCustomerId}`;
          hint.style.display = 'block';
        } else {
          input.value = '';
          input.dataset.selectedValue = '';
          input.dataset.selectedDisplayName = '';
          noMapOption.classList.add('selected');
          hint.style.display = 'none';
        }
        
        input.setAttribute('readonly', 'readonly');
        
        // Setup dropdown behavior
        setupCustomDropdown(input, dropdown, (value, text, displayName) => {
          input.value = text;
          input.dataset.selectedValue = value;
          input.dataset.selectedDisplayName = displayName || '';
          if (value) {
            hint.textContent = `Mapped to customer ID: ${value}`;
            hint.style.display = 'block';
          } else {
            hint.style.display = 'none';
          }
        });
      } catch (error) {
        console.error('Error loading customers:', error);
        dropdown.innerHTML = '';
        const errorOption = document.createElement('div');
        errorOption.className = 'custom-select-no-results';
        errorOption.textContent = 'Error loading customers';
        dropdown.appendChild(errorOption);
      }
    }

    // Region mapping dropdown
    async function populateRegionMappingDropdown(node) {
      const input = document.getElementById('editRegionMapping');
      const dropdown = document.getElementById('editRegionMappingDropdown');
      const hint = document.getElementById('regionMappingHint');
      
      dropdown.innerHTML = '';
      
      const loadingOption = document.createElement('div');
      loadingOption.className = 'custom-select-no-results';
      loadingOption.textContent = 'Loading regions...';
      dropdown.appendChild(loadingOption);
      
      try {
        const response = await fetch('/api/bq/regions');
        if (!response.ok) {
          throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        const regions = await response.json();
        
        dropdown.innerHTML = '';
        
        const noMapOption = document.createElement('div');
        noMapOption.className = 'custom-select-option';
        noMapOption.textContent = '(No region mapped)';
        noMapOption.dataset.value = '';
        dropdown.appendChild(noMapOption);
        
        const currentData = AppState.dimensions[AppState.currentDimension];
        const mappedRegionIds = new Set();
        
        for (const [itemId, itemData] of Object.entries(currentData)) {
          if (itemId !== node.id && itemData.region_internal_id) {
            mappedRegionIds.add(parseInt(itemData.region_internal_id));
          }
        }
        
        let selectedText = '';
        const nodeRegionId = node.region_internal_id;
        
        regions.forEach(region => {
          const option = document.createElement('div');
          option.className = 'custom-select-option';
          const baseText = `Region ${region.region_internal_id}`;
          option.textContent = baseText;
          option.dataset.value = region.region_internal_id;
          option.dataset.displayName = `Region ${region.region_internal_id}`;
          
          const isCurrentSelection = nodeRegionId && parseInt(nodeRegionId) === parseInt(region.region_internal_id);
          const isAlreadyMapped = mappedRegionIds.has(parseInt(region.region_internal_id));
          
          if (isAlreadyMapped) {
            option.classList.add('disabled');
            option.textContent += ' (already mapped)';
          }
          
          if (isCurrentSelection) {
            option.classList.add('selected');
            selectedText = baseText;
          }
          
          dropdown.appendChild(option);
        });
        
        if (nodeRegionId && selectedText) {
          input.value = selectedText;
          input.dataset.selectedValue = nodeRegionId;
          hint.textContent = `Mapped to region ID: ${nodeRegionId}`;
          hint.style.display = 'block';
        } else {
          input.value = '';
          input.dataset.selectedValue = '';
          noMapOption.classList.add('selected');
          hint.style.display = 'none';
        }
        
        input.setAttribute('readonly', 'readonly');
        
        setupCustomDropdown(input, dropdown, (value, text, displayName) => {
          input.value = text;
          input.dataset.selectedValue = value;
          if (value) {
            hint.textContent = `Mapped to region ID: ${value}`;
            hint.style.display = 'block';
          } else {
            hint.style.display = 'none';
          }
        });
      } catch (error) {
        console.error('Error loading regions:', error);
        dropdown.innerHTML = '';
        const errorOption = document.createElement('div');
        errorOption.className = 'custom-select-no-results';
        errorOption.textContent = 'Error loading regions';
        dropdown.appendChild(errorOption);
      }
    }

    // Department/Subsidiary mapping dropdown
    async function populateDepartmentMappingDropdown(node) {
      const input = document.getElementById('editDepartmentMapping');
      const dropdown = document.getElementById('editDepartmentMappingDropdown');
      const hint = document.getElementById('departmentMappingHint');
      
      dropdown.innerHTML = '';
      
      const loadingOption = document.createElement('div');
      loadingOption.className = 'custom-select-no-results';
      loadingOption.textContent = 'Loading subsidiaries...';
      dropdown.appendChild(loadingOption);
      
      try {
        const response = await fetch('/api/bq/subsidiaries');
        if (!response.ok) {
          throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        const subsidiaries = await response.json();
        
        dropdown.innerHTML = '';
        
        const noMapOption = document.createElement('div');
        noMapOption.className = 'custom-select-option';
        noMapOption.textContent = '(No subsidiary mapped)';
        noMapOption.dataset.value = '';
        dropdown.appendChild(noMapOption);
        
        const currentData = AppState.dimensions[AppState.currentDimension];
        const mappedSubsidiaryIds = new Set();
        
        for (const [itemId, itemData] of Object.entries(currentData)) {
          if (itemId !== node.id && itemData.subsidiary_internal_id) {
            mappedSubsidiaryIds.add(parseInt(itemData.subsidiary_internal_id));
          }
        }
        
        let selectedText = '';
        const nodeSubsidiaryId = node.subsidiary_internal_id;
        
        subsidiaries.forEach(subsidiary => {
          const option = document.createElement('div');
          option.className = 'custom-select-option';
          const baseText = subsidiary.display_name_with_id || `${subsidiary.display_name} (${subsidiary.subsidiary_id})`;
          option.textContent = baseText;
          option.dataset.value = subsidiary.subsidiary_id;
          option.dataset.displayName = subsidiary.display_name;
          
          const isCurrentSelection = nodeSubsidiaryId && parseInt(nodeSubsidiaryId) === parseInt(subsidiary.subsidiary_id);
          const isAlreadyMapped = mappedSubsidiaryIds.has(parseInt(subsidiary.subsidiary_id));
          
          if (isAlreadyMapped) {
            option.classList.add('disabled');
            option.textContent += ' (already mapped)';
          }
          
          if (isCurrentSelection) {
            option.classList.add('selected');
            selectedText = baseText;
          }
          
          dropdown.appendChild(option);
        });
        
        if (nodeSubsidiaryId && selectedText) {
          input.value = selectedText;
          input.dataset.selectedValue = nodeSubsidiaryId;
          input.dataset.selectedDisplayName = subsidiaries.find(s => parseInt(s.subsidiary_id) === parseInt(nodeSubsidiaryId))?.display_name || '';
          hint.textContent = `Mapped to subsidiary ID: ${nodeSubsidiaryId}`;
          hint.style.display = 'block';
        } else {
          input.value = '';
          input.dataset.selectedValue = '';
          input.dataset.selectedDisplayName = '';
          noMapOption.classList.add('selected');
          hint.style.display = 'none';
        }
        
        input.setAttribute('readonly', 'readonly');
        
        setupCustomDropdown(input, dropdown, (value, text, displayName) => {
          input.value = text;
          input.dataset.selectedValue = value;
          input.dataset.selectedDisplayName = displayName || '';
          if (value) {
            hint.textContent = `Mapped to subsidiary ID: ${value}`;
            hint.style.display = 'block';
          } else {
            hint.style.display = 'none';
          }
        });
      } catch (error) {
        console.error('Error loading subsidiaries:', error);
        dropdown.innerHTML = '';
        const errorOption = document.createElement('div');
        errorOption.className = 'custom-select-no-results';
        errorOption.textContent = 'Error loading subsidiaries';
        dropdown.appendChild(errorOption);
      }
    }

    async function populateAccountMappingDropdown(node) {
      const input = document.getElementById('editAccountMapping');
      const dropdown = document.getElementById('editAccountMappingDropdown');
      const hint = document.getElementById('accountMappingHint');
      
      // Clear existing options
      dropdown.innerHTML = '';
      
      // Show loading state
      const loadingOption = document.createElement('div');
      loadingOption.className = 'custom-select-no-results';
      loadingOption.textContent = 'Loading accounts...';
      dropdown.appendChild(loadingOption);
      
      try {
        // Fetch accounts from API
        const response = await fetch('/api/accounts');
        if (!response.ok) {
          throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        const accounts = await response.json();
        
        // Clear loading state
        dropdown.innerHTML = '';
        
        // Create "No account mapped" option
        const noMapOption = document.createElement('div');
        noMapOption.className = 'custom-select-option';
        noMapOption.textContent = '(No account mapped)';
        noMapOption.dataset.value = '';
        dropdown.appendChild(noMapOption);
        
        // Get all already-mapped account IDs (excluding current node)
        const currentData = AppState.dimensions[AppState.currentDimension];
        const mappedAccountIds = new Set();
        
        for (const [itemId, itemData] of Object.entries(currentData)) {
          if (itemId !== node.id && itemData.account_internal_id) {
            mappedAccountIds.add(parseInt(itemData.account_internal_id));
          }
        }
        
        // Add all account options
        let selectedText = '';
        accounts.forEach(account => {
          const option = document.createElement('div');
          option.className = 'custom-select-option';
          const baseText = account.display_name_with_id || `${account.display_name} (${account.account_id})`;
          option.textContent = baseText;
          option.dataset.value = account.account_id;
          
          // Check if this is the currently selected account
          const isCurrentSelection = node.account_internal_id && parseInt(node.account_internal_id) === parseInt(account.account_id);
          
          // Check if this account is already mapped to another item
          const isAlreadyMapped = mappedAccountIds.has(parseInt(account.account_id));
          
          if (isAlreadyMapped) {
            option.classList.add('disabled');
            option.textContent += ' (already mapped)';
          }
          
          if (isCurrentSelection) {
            option.classList.add('selected');
            // Use base text for selected text (without "already mapped")
            selectedText = baseText;
          }
          
          dropdown.appendChild(option);
        });
        
        // Set input value and hint
        if (node.account_internal_id && selectedText) {
          input.value = selectedText;
          input.dataset.selectedValue = node.account_internal_id;
          hint.textContent = `Mapped to account ID: ${node.account_internal_id}`;
          hint.style.display = 'block';
        } else {
          input.value = '';
          input.dataset.selectedValue = '';
          noMapOption.classList.add('selected');
          hint.style.display = 'none';
        }
        
        input.setAttribute('readonly', 'readonly');
        
        // Setup dropdown behavior
        setupCustomDropdown(input, dropdown, (value, text) => {
          input.value = text;
          input.dataset.selectedValue = value;
          if (value) {
            hint.textContent = `Mapped to account ID: ${value}`;
            hint.style.display = 'block';
          } else {
            hint.style.display = 'none';
          }
        });
      } catch (error) {
        console.error('Error loading accounts:', error);
        dropdown.innerHTML = '';
        const errorOption = document.createElement('div');
        errorOption.className = 'custom-select-no-results';
        errorOption.textContent = 'Error loading accounts';
        dropdown.appendChild(errorOption);
      }
    }

    function populateParentDropdown(node) {
      const input = document.getElementById('editParent');
      const dropdown = document.getElementById('editParentDropdown');
      
      // Clear existing options
      dropdown.innerHTML = '';
      
      // Create "Root Level" option
      const rootOption = document.createElement('div');
      rootOption.className = 'custom-select-option';
      rootOption.textContent = '(Root Level)';
      rootOption.dataset.value = '';
      dropdown.appendChild(rootOption);
      
      // Get all nodes and build parent options (excluding self and descendants)
      const currentData = AppState.dimensions[AppState.currentDimension];
      if (!currentData) return;
      
      let selectedText = '(Root Level)';
      
      // Recursively add all valid parent options
      function addParentOptions(nodes, level = 0) {
        for (const [id, data] of Object.entries(nodes)) {
          // Skip the current node
          if (id === node.id) continue;
          
          // Skip if this node is a descendant of the current node
          if (isDescendant(id, node.id, currentData)) continue;
          
          const option = document.createElement('div');
          option.className = 'custom-select-option';
          const indent = '  '.repeat(level);
          option.textContent = `${indent}${data.label || id}`;
          option.dataset.value = id;
          
          if (node.parent === id) {
            option.classList.add('selected');
            selectedText = option.textContent;
          }
          
          dropdown.appendChild(option);
        }
      }
      
      addParentOptions(currentData);
      
      // Set selected value and data attribute
      input.value = selectedText;
      input.dataset.selectedValue = node.parent || '';
      input.setAttribute('readonly', 'readonly');
      if (!node.parent) {
        rootOption.classList.add('selected');
      }
      
      // Setup dropdown behavior
      setupCustomDropdown(input, dropdown);
    }

    function setupCustomDropdown(input, dropdown, onChange) {
      // Store the selected value for restoration
      let originalValue = input.value;
      let isInputHandlerAdded = false;
      
      // Toggle dropdown on input click
      input.addEventListener('click', (e) => {
        e.stopPropagation();
        const isOpen = dropdown.classList.contains('show');
        
        // Close all other dropdowns
        document.querySelectorAll('.custom-select-dropdown.show').forEach(d => {
          if (d !== dropdown) d.classList.remove('show');
        });
        
        // Toggle this dropdown
        if (!isOpen) {
          // Opening dropdown
          dropdown.classList.add('show');
          input.style.borderRadius = '4px 4px 0 0';
          
          // Store current value and clear input for searching
          originalValue = input.value;
          input.value = '';
          input.removeAttribute('readonly');
          input.focus();
          
          // Reset all options to visible
          dropdown.querySelectorAll('.custom-select-option').forEach(opt => {
            opt.classList.remove('hidden');
          });
          
          // Remove any "no results" message
          const noResults = dropdown.querySelector('.custom-select-no-results');
          if (noResults) {
            noResults.remove();
          }
        } else {
          // Closing dropdown
          closeDropdown();
        }
      });
      
      // Add input handler for filtering (only once)
      if (!isInputHandlerAdded) {
        input.addEventListener('input', (e) => {
          if (!dropdown.classList.contains('show')) return;
          
          const searchTerm = e.target.value.toLowerCase();
          const options = dropdown.querySelectorAll('.custom-select-option');
          let visibleCount = 0;
          
          options.forEach(option => {
            const text = option.textContent.toLowerCase();
            const matches = text.includes(searchTerm);
            
            if (matches) {
              option.classList.remove('hidden');
              visibleCount++;
            } else {
              option.classList.add('hidden');
            }
          });
          
          // Show "no results" message if no matches
          let noResults = dropdown.querySelector('.custom-select-no-results');
          if (visibleCount === 0) {
            if (!noResults) {
              noResults = document.createElement('div');
              noResults.className = 'custom-select-no-results';
              noResults.textContent = 'No matching options';
              dropdown.appendChild(noResults);
            }
          } else if (noResults) {
            noResults.remove();
          }
        });
        isInputHandlerAdded = true;
      }
      
      // Handle option clicks
      dropdown.addEventListener('click', (e) => {
        if (e.target.classList.contains('custom-select-option')) {
          // Don't allow clicking disabled options
          if (e.target.classList.contains('disabled')) {
            return;
          }
          
          const value = e.target.dataset.value;
          const text = e.target.textContent;
          const displayName = e.target.dataset.displayName || '';
          
          // Update selected state
          dropdown.querySelectorAll('.custom-select-option').forEach(opt => {
            opt.classList.remove('selected');
          });
          e.target.classList.add('selected');
          
          // Update input and store selected value
          input.value = text;
          input.dataset.selectedValue = value;
          if (displayName) {
            input.dataset.selectedDisplayName = displayName;
          }
          originalValue = text;
          input.setAttribute('readonly', 'readonly');
          
          // Call onChange callback if provided
          if (onChange) {
            onChange(value, text, displayName);
          }
          
          // Close dropdown
          dropdown.classList.remove('show');
          input.style.borderRadius = '4px';
        }
      });
      
      // Function to close dropdown and restore value
      function closeDropdown() {
        dropdown.classList.remove('show');
        input.style.borderRadius = '4px';
        input.value = originalValue;
        input.setAttribute('readonly', 'readonly');
        
        // Reset all options to visible
        dropdown.querySelectorAll('.custom-select-option').forEach(opt => {
          opt.classList.remove('hidden');
        });
        
        // Remove any "no results" message
        const noResults = dropdown.querySelector('.custom-select-no-results');
        if (noResults) {
          noResults.remove();
        }
      }
      
      // Close on outside click
      document.addEventListener('click', (e) => {
        if (dropdown.classList.contains('show') && !input.contains(e.target) && !dropdown.contains(e.target)) {
          closeDropdown();
        }
      });
    }

    function isDescendant(nodeId, ancestorId, flatData) {
      let currentId = nodeId;
      while (currentId) {
        const nodeData = flatData[currentId];
        if (!nodeData) break;
        
        if (nodeData.parent === ancestorId) {
          return true;
        }
        
        currentId = nodeData.parent;
      }
      return false;
    }

    // Initialize - load and expand all by default
    document.addEventListener('DOMContentLoaded', () => {
      switchDimension('account');
    });
  </script>
</body>
</html>
